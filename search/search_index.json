{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"casimirpolder/","text":"Van der Waals interactions (also called Casimir-Polder forces) tend to bring the atoms closer to the surface. They depend on the atom, its atomic level and on the material they are approaching. Their action is only on very short distances (usually on the order of 100nm) but when looking at atoms close to surface with high refractive index, they sometimes have to be taken into account. Our approach is to set surfaces, for now only Cylinders and Planes which match the surface of interest of our waveguide.","title":"On Casimir Polder interactions"},{"location":"credit/","text":"We would like to thank here Malik Kemiche and Nikos Fayard for fruitful discussions. This work was supported by the French National Research Agency NanoStrong Project (ANR-18-CE47-0008), and the R\u00e9gion Ile-de-France (DIM SIRTEQ). This project has also received funding from the European Union\u2019s Horizon 2020 research and innovation programme under Grant Agreement No. 899275 (DAALI project). A.U. was supported by the European Union (Marie Curie Fellowship SinglePass 101030421). Third-party packages used for this project, which we would like to thank: ARC-Alkali-Rydberg-Calculator : https://arc-alkali-rydberg-calculator.readthedocs.io/en/latest/ Material for MkDocs: https://squidfunk.github.io/mkdocs-material/","title":"Credits"},{"location":"getting-started/","text":"Getting started \u00b6 Nanotrappy can be directly used from GitHub by cloning the repository on your device. git clone https://github.com/jrmbr/nanotrappy.git Installation in a virtual environment (Recommended) \u00b6 Compatibility has been tested for python 3.7, 3.8 and 3.9 on Windows and Linux. We recommend setting up a new virtual environment for installing nanotrappy , preferably with Anaconda, with Python version specified. Numpy has to be installed before building the package. As follows : Windows First install a python distribution on you computer. Here we use the Miniconda3 distribution (can be found easily using your favorite search engine). Then, if you want to be safe, create a new environment and install numpy and the package inside, in this order. conda create --name yourenvname python=3.8 conda activate yourenvname conda install numpy If you don't have Anaconda, and using Windows, this also works. python -m venv yourenvname .\\yourenvname\\Scripts\\activate pip install numpy Once the package is cloned you simply need to install it on your local device. For this, navigate into the package folder (while still in your virtual environment) and run: pip install . This will automatically install compatible versions of all dependencies, which most importantly contain Legume and ARC-Alkali-Rydberg-Calculator . When you are finished working, you can leave the environment using: conda deactivate When you want to use the package, juste activate this environment again and you are good to go ! conda activate yourenvname Linux First install a python distribution on you computer. Here we use the Miniconda3 distribution (can be found easily using your favorite search engine). Download the .sh file corresponding to your system configuration and install it. Then, if you want to be safe, create a new environment and install numpy and the package inside, in this order. conda create --name yourenvname python=3.8 conda activate yourenvname conda install numpy Once the package is cloned you simply need to install it on your local device. For this, navigate into the package folder (while still in your virtual environment) and run: pip install . This will automatically install compatible versions of all dependencies, which most importantly contain Legume and ARC-Alkali-Rydberg-Calculator . When you are finished working, you can leave the environment using: conda deactivate When you want to use the package, juste activate this environment again and you are good to go ! conda activate yourenvname","title":"Installation"},{"location":"getting-started/#getting-started","text":"Nanotrappy can be directly used from GitHub by cloning the repository on your device. git clone https://github.com/jrmbr/nanotrappy.git","title":"Getting started"},{"location":"getting-started/#installation-in-a-virtual-environment-recommended","text":"Compatibility has been tested for python 3.7, 3.8 and 3.9 on Windows and Linux. We recommend setting up a new virtual environment for installing nanotrappy , preferably with Anaconda, with Python version specified. Numpy has to be installed before building the package. As follows : Windows First install a python distribution on you computer. Here we use the Miniconda3 distribution (can be found easily using your favorite search engine). Then, if you want to be safe, create a new environment and install numpy and the package inside, in this order. conda create --name yourenvname python=3.8 conda activate yourenvname conda install numpy If you don't have Anaconda, and using Windows, this also works. python -m venv yourenvname .\\yourenvname\\Scripts\\activate pip install numpy Once the package is cloned you simply need to install it on your local device. For this, navigate into the package folder (while still in your virtual environment) and run: pip install . This will automatically install compatible versions of all dependencies, which most importantly contain Legume and ARC-Alkali-Rydberg-Calculator . When you are finished working, you can leave the environment using: conda deactivate When you want to use the package, juste activate this environment again and you are good to go ! conda activate yourenvname Linux First install a python distribution on you computer. Here we use the Miniconda3 distribution (can be found easily using your favorite search engine). Download the .sh file corresponding to your system configuration and install it. Then, if you want to be safe, create a new environment and install numpy and the package inside, in this order. conda create --name yourenvname python=3.8 conda activate yourenvname conda install numpy Once the package is cloned you simply need to install it on your local device. For this, navigate into the package folder (while still in your virtual environment) and run: pip install . This will automatically install compatible versions of all dependencies, which most importantly contain Legume and ARC-Alkali-Rydberg-Calculator . When you are finished working, you can leave the environment using: conda deactivate When you want to use the package, juste activate this environment again and you are good to go ! conda activate yourenvname","title":"Installation in a virtual environment (Recommended)"},{"location":"modeformatting/","text":"In order to be used by nanotrappy , the fields in the data folder have to have a specific formatting. The names of the files don't matter nor their order. Attention The files must be numpy arrays stored in .npy files. The array must be done as follows mode.npy : np.array(lambda, x, y, z, E) where E is a 4-dimensional np.array of size **(3,len(x),len(y),len(z))**. The first dimension corresponds to Ex, Ey and Ez. The program will check all the .npy files in the specified folder, open them and store the first element (the wavelength) in a list. It will then compare it to the specified wavelengths for trapping to check is the modes are available.","title":"Formatting your data"},{"location":"tutorial/","text":"State insensitive trap around a nanofiber \u00b6 1 2 3 4 5 6 7 8 9 import nanotrappy import nanotrappy.trapping.atomicsystem as Na import nanotrappy.trapping.beam as Nb import nanotrappy.trapping.trap as Nt import nanotrappy.trapping.simulation as Ns import nanotrappy.utils.materials as Nm import nanotrappy.utils.viz as Nv import nanotrappy.utils.vdw as vdw from nanotrappy.utils.physicalunits import * In this tutorial we will reproduce the trapping schemes around a nanofiber discussed in Lacro\u00fbte et al. \"A state-insensitive, compensated nanofiber trap\" New J. Phys. 14 (2012). Use the pre-implemented nanofiber field calculations \u00b6 Creating the beams and trapping scheme \u00b6 There are many different designs that can be used for trapping atoms with evanescent fields. We have then to specify how many beams we want to use, at which wavelengths and powers. If the structures are pre-implemented in nanotrappy , the right modes will then be computed. If not, a folder containing the modes will have to be specified, consult the mode formatting section to see how the modes have to be saved in order to be used by nanotrappy . Beam objects are the basic building blocks of your trap in nanotrappy . 2 3 blue_beam = Nb . Beam ( 1064e-9 , \"f\" , 25 * mW ) red_beam = Nb . Beam ( 780e-9 , \"f\" , 7 * mW ) Here we define two beams, blue- and red-detuned from the Cesium D2 line respectively. \"f\" means the beam is propagating forward, along the propagation axis of the waveguide that will be specified later. \"b\" stands for backwards. This is important as chiral effects can arise when coupling tightly focused light to quantum emitters for example. These beams are bundled into a trap object, where a propagation axis is specified. 4 trap = Nt . Trap_beams ( blue_beam , red_beam , propagation_axis = \"Z\" ) Specifying the atom we want to trap \u00b6 This part is based on the Alkali Rydberg Calculator library. Originally conceived for studying Rydberg atoms, we have included the hyperfine levels of such Alkali. 5 syst = Na . atomicsystem ( Caesium (), Na . atomiclevel ( 6 , S , 1 / 2 ), f = 4 ) An alkali atom has to be chosen, an atomic level from the fine structure (here the ground state of Cesium 6S\u00bd) and the F of the hyperfine level studied. Indeed the dipole force felt by the atoms depends on the hyperfine level they are in. Optional : Set surfaces for the Van der Waals interactions \u00b6 See the dedicated page for more information. The nanofiber is a cylinder with axis of symmetry the propagation axis. We define then a cylinder centered at the origin of the grid, with 250 nm radius and with \"Z\" revolution axis. 6 surface = vdw . Cylinder (( 0 , 0 ), 250e-9 , \"Z\" ) Define the Simulation object \u00b6 The simulation object will then be a bundle of everything needed to compute the trapping potentials. The right modes corresponding to the trapping scheme, the atomic level and the surface and material (for CP interactions). This class will be useful mostly for keeping the results of the simulation and visualisation purposes further on. 7 Simul = Ns . Simulation ( syst , Nm . SiO2 (), trap , datafolder , surface ) Run the simulation in 2 dimensions \u00b6 8 trap2D = Simul . compute_potential ( \"XY\" , 0 ) Careful that the simulation in 2D can be time consuming as the potential is computed point by point on the given grid. As an example, for a 100x100 grid, times of the order of 30s are expected. Visualizing the results \u00b6 The viz submodules has a few methods to visualise and analyze your results. The easiest is to plot the 2D potential with power sliders as follows : 9 fig , ax , slider_ax = Nv . plot_trap ( Simul , \"XY\" ) It is important to return the image and sliders as this will ensure the sliders do not get stuck. We see here 2 trapping sites, one on each side of the fiber (around 230 nm from the surface each). We can also look at a cut in 1D for easier analysis. If you are satisfied, you can save your simulation with Simul.save() . This will create a new folder in your mode folder and save a JSON file with the list of parameters of the simulation as well as a NPY with the potentials (not summed). When you run a simulation nanotrappy looks in the results folder if a simulation with the same parameters has been already saved. If so, it just opens it without running the simulation again. A 1D simulation can also be run to look at how the different mf states are affected by the differential vector shift coming from the local circular polarisation of the light acting as a fictitious magnetic field. 10 11 12 trap1D = Simul . compute_potential_1D ( 'X' , 0 , 0 ) fig , ax , slider_ax = Nv . plot_trap1D ( Simul , \"X\" ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ]) Simul . save ()","title":"Tutorial"},{"location":"tutorial/#state-insensitive-trap-around-a-nanofiber","text":"1 2 3 4 5 6 7 8 9 import nanotrappy import nanotrappy.trapping.atomicsystem as Na import nanotrappy.trapping.beam as Nb import nanotrappy.trapping.trap as Nt import nanotrappy.trapping.simulation as Ns import nanotrappy.utils.materials as Nm import nanotrappy.utils.viz as Nv import nanotrappy.utils.vdw as vdw from nanotrappy.utils.physicalunits import * In this tutorial we will reproduce the trapping schemes around a nanofiber discussed in Lacro\u00fbte et al. \"A state-insensitive, compensated nanofiber trap\" New J. Phys. 14 (2012).","title":"State insensitive trap around a nanofiber"},{"location":"tutorial/#use-the-pre-implemented-nanofiber-field-calculations","text":"","title":"Use the pre-implemented nanofiber field calculations"},{"location":"tutorial/#creating-the-beams-and-trapping-scheme","text":"There are many different designs that can be used for trapping atoms with evanescent fields. We have then to specify how many beams we want to use, at which wavelengths and powers. If the structures are pre-implemented in nanotrappy , the right modes will then be computed. If not, a folder containing the modes will have to be specified, consult the mode formatting section to see how the modes have to be saved in order to be used by nanotrappy . Beam objects are the basic building blocks of your trap in nanotrappy . 2 3 blue_beam = Nb . Beam ( 1064e-9 , \"f\" , 25 * mW ) red_beam = Nb . Beam ( 780e-9 , \"f\" , 7 * mW ) Here we define two beams, blue- and red-detuned from the Cesium D2 line respectively. \"f\" means the beam is propagating forward, along the propagation axis of the waveguide that will be specified later. \"b\" stands for backwards. This is important as chiral effects can arise when coupling tightly focused light to quantum emitters for example. These beams are bundled into a trap object, where a propagation axis is specified. 4 trap = Nt . Trap_beams ( blue_beam , red_beam , propagation_axis = \"Z\" )","title":"Creating the beams and trapping scheme"},{"location":"tutorial/#specifying-the-atom-we-want-to-trap","text":"This part is based on the Alkali Rydberg Calculator library. Originally conceived for studying Rydberg atoms, we have included the hyperfine levels of such Alkali. 5 syst = Na . atomicsystem ( Caesium (), Na . atomiclevel ( 6 , S , 1 / 2 ), f = 4 ) An alkali atom has to be chosen, an atomic level from the fine structure (here the ground state of Cesium 6S\u00bd) and the F of the hyperfine level studied. Indeed the dipole force felt by the atoms depends on the hyperfine level they are in.","title":"Specifying the atom we want to trap"},{"location":"tutorial/#optional-set-surfaces-for-the-van-der-waals-interactions","text":"See the dedicated page for more information. The nanofiber is a cylinder with axis of symmetry the propagation axis. We define then a cylinder centered at the origin of the grid, with 250 nm radius and with \"Z\" revolution axis. 6 surface = vdw . Cylinder (( 0 , 0 ), 250e-9 , \"Z\" )","title":"Optional : Set surfaces for the Van der Waals interactions"},{"location":"tutorial/#define-the-simulation-object","text":"The simulation object will then be a bundle of everything needed to compute the trapping potentials. The right modes corresponding to the trapping scheme, the atomic level and the surface and material (for CP interactions). This class will be useful mostly for keeping the results of the simulation and visualisation purposes further on. 7 Simul = Ns . Simulation ( syst , Nm . SiO2 (), trap , datafolder , surface )","title":"Define the Simulation object"},{"location":"tutorial/#run-the-simulation-in-2-dimensions","text":"8 trap2D = Simul . compute_potential ( \"XY\" , 0 ) Careful that the simulation in 2D can be time consuming as the potential is computed point by point on the given grid. As an example, for a 100x100 grid, times of the order of 30s are expected.","title":"Run the simulation in 2 dimensions"},{"location":"tutorial/#visualizing-the-results","text":"The viz submodules has a few methods to visualise and analyze your results. The easiest is to plot the 2D potential with power sliders as follows : 9 fig , ax , slider_ax = Nv . plot_trap ( Simul , \"XY\" ) It is important to return the image and sliders as this will ensure the sliders do not get stuck. We see here 2 trapping sites, one on each side of the fiber (around 230 nm from the surface each). We can also look at a cut in 1D for easier analysis. If you are satisfied, you can save your simulation with Simul.save() . This will create a new folder in your mode folder and save a JSON file with the list of parameters of the simulation as well as a NPY with the potentials (not summed). When you run a simulation nanotrappy looks in the results folder if a simulation with the same parameters has been already saved. If so, it just opens it without running the simulation again. A 1D simulation can also be run to look at how the different mf states are affected by the differential vector shift coming from the local circular polarisation of the light acting as a fictitious magnetic field. 10 11 12 trap1D = Simul . compute_potential_1D ( 'X' , 0 , 0 ) fig , ax , slider_ax = Nv . plot_trap1D ( Simul , \"X\" ,[ - 4 , - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 ]) Simul . save ()","title":"Visualizing the results"},{"location":"reference/atomicsystem/","text":"\u00b6 atomiclevel \u00b6 This is the class that implements the atomic levels. An atomiclevel object is used as a container for the three quantum numbers n, l and j of the considered level Note Some method to define an order between levels is implemented, even though it is not in use right now. Attributes: Name Type Description n int Principal quantum number. l int Azimuthal (orbital angular momentum) quantum number. j int or half-int) Total angular momentum quantum number. Examples: In order to create an atomic level, one can just write: >>> level = atomiclevel ( 6 , P , 1 / 2 ) >>> print ( level ) 6 P1 / 2 __str__ ( self ) special \u00b6 str : Formatted print of an atomic level, using the usual S, P, D... notation. Source code in nanotrappy\\trapping\\atomicsystem.py def __str__ ( self ): \"\"\"str : Formatted print of an atomic level, using the usual S, P, D... notation.\"\"\" if self . l == 0 : return str ( self . n ) + \"S\" + asfraction ( self . j ) elif self . l == 1 : return str ( self . n ) + \"P\" + asfraction ( self . j ) elif self . l == 2 : return str ( self . n ) + \"D\" + asfraction ( self . j ) atomicsystem \u00b6 This is the class that implements the atomic system under study. It calls the ARC Rydberg calculator in the background to collect all the datas available for the chosen atom. All the information of the states to which the ground state and the excited state couple to are stored in a array of dictionnaries. dicoatom is the dictionnary for the selected state The coupled states are given by a triplet (n,l,j). Note Some method to define an order between levels is implemented, even though it is not in use right now. Attributes: Name Type Description atom atom The atom selected among ARC catalog (ex: Caesium(), Rubidium87()...). state atomiclevel The atomic level considered as the state of interest. f int Hyperfine level. Nground int the principal quantum number of the ground state (for computationnal use). listlevels list[atomiclevel] list of the atomic levels coupled to the state. dicoatom list[dict] dictionnary of the physical quantities, to avoid using ARC methods every time. Note The format of the dictionnaries is the following: To each atomic level is associated a triplet (f,rde,gamma) where f is the transition frequency to this level, rde is the reduced matrix element of the transition and gamma is the transition rate. Examples: An atomic system is created as follow: >>> atomic_system = atomicsystem ( Rubidium87 (), atomiclevel ( 5 , S , 1 / 2 ), f = 2 ) Additionnaly, a parser is provided so that the following is also valid: >>> atomic_system = atomicsystem ( Rubidium87 (), \"5S1/2\" , f = 2 ) alpha_scalar ( self , lmbda ) \u00b6 This function returns the scalar polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Parameters: Name Type Description Default lmbda float Wavelength at which to compute the polarizability. required Returns: Type Description float Scalar polarizability for the given parameters. Examples: >>> syst . alpha0 ( 780e-9 ) / AMU - 329596.9660348868 Source code in nanotrappy\\trapping\\atomicsystem.py def alpha_scalar ( self , lmbda ): \"\"\"This function returns the scalar polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Args: lmbda (float): Wavelength at which to compute the polarizability. Returns: float: Scalar polarizability for the given parameters. Example: >>> syst.alpha0(780e-9)/AMU -329596.9660348868 \"\"\" if self . f > self . I + self . state . j or self . f < abs ( self . I - self . state . j ): raise ValueError ( \"F should be in the interval [|I-J|,I+J]\" ) tot = 0.0 freq = 0.0 sign = 1.0 coupledlevels = self . listlevels couplings = self . dicoatom for level in coupledlevels : c = couplings [( level . n , level . l , level . j )] gamma = c [ 2 ] omega = 2 * np . pi * c [ 0 ] rde = abs ( c [ 1 ]) freq = np . real ( 1 / ( sign * omega - ( 2 * np . pi * cc / lmbda ) - 1 j * gamma / 2 ) + 1 / ( sign * omega + ( 2 * np . pi * cc / lmbda ) + 1 j * gamma / 2 ) ) for fsum in np . arange ( abs ( level . j - self . I ), abs ( level . j + self . I ) + 1 , 1 ): tot += ( rde * np . conj ( rde ) * freq * ( 2 * fsum + 1 ) * ( self . wigner6j [ int ( level . j - 1 / 2 ), int ( self . f - abs ( self . state . j - self . I )), int ( fsum - 1 )]) ** 2 ) tot = ( 1 / ( 3 * hbar )) * au ** 2 * tot if self . state == self . groundstate : tot += self . alpha_core * AMU return tot alpha_tensor ( self , lmbda ) \u00b6 This function returns the tensor polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Parameters: Name Type Description Default lmbda float Wavelength at which to compute the polarizability. required Returns: Type Description float Tensor polarizability for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def alpha_tensor ( self , lmbda ): \"\"\"This function returns the tensor polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Args: lmbda (float): Wavelength at which to compute the polarizability. Returns: float: Tensor polarizability for the given parameters. \"\"\" if self . f > self . I + self . state . j or self . f < abs ( self . I - self . state . j ): raise ValueError ( \"F should be in the interval [|I-J|,I+J]\" ) tot = 0.0 freq = 0.0 sign = 1.0 coupledlevels = self . listlevels couplings = self . dicoatom for level in coupledlevels : c = couplings [( level . n , level . l , level . j )] gamma = c [ 2 ] omega = 2 * np . pi * c [ 0 ] rde = abs ( c [ 1 ]) freq = np . real ( 1 / ( sign * omega - ( 2 * np . pi * cc / lmbda ) - 1 j * gamma / 2 ) + 1 / ( sign * omega + ( 2 * np . pi * cc / lmbda ) + 1 j * gamma / 2 ) ) for fsum in np . arange ( abs ( level . j - self . I ), abs ( level . j + self . I ) + 1 , 1 ): tot += ( rde * np . conj ( rde ) * ( - 1 ) ** ( self . f + fsum ) * np . sqrt ( 10 * self . f * ( 2 * self . f + 1 ) * ( 2 * self . f - 1 ) / ( 3 * ( self . f + 1 ) * ( 2 * self . f + 3 ))) * wigner6j12 ( 1 , 1 , 2 , self . f , self . f , fsum ) * freq * ( 2 * fsum + 1 ) * self . wigner6j [ int ( level . j - 1 / 2 ), int ( self . f - abs ( self . state . j - self . I )), int ( fsum - 1 )] ** 2 ) tot = ( 1 / ( hbar )) * au ** 2 * tot return tot alpha_vector ( self , lmbda ) \u00b6 This function returns the vector polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Parameters: Name Type Description Default lmbda float Wavelength at which to compute the polarizability. required Returns: Type Description float Vector polarizability for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def alpha_vector ( self , lmbda ): \"\"\"This function returns the vector polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Args: lmbda (float): Wavelength at which to compute the polarizability. Returns: float: Vector polarizability for the given parameters. \"\"\" if self . f > self . I + self . state . j or self . f < abs ( self . I - self . state . j ): raise ValueError ( \"F should be in the interval [|I-J|,I+J]\" ) tot = 0.0 freq = 0.0 sign = 1.0 coupledlevels = self . listlevels couplings = self . dicoatom for level in coupledlevels : c = couplings [( level . n , level . l , level . j )] gamma = c [ 2 ] omega = 2 * np . pi * c [ 0 ] rde = abs ( c [ 1 ]) freq = np . real ( 1 / ( sign * omega - ( 2 * np . pi * cc / lmbda ) - 1 j * gamma / 2 ) - 1 / ( sign * omega + ( 2 * np . pi * cc / lmbda ) + 1 j * gamma / 2 ) ) for fsum in np . arange ( abs ( level . j - self . I ), abs ( level . j + self . I ) + 1 , 1 ): tot += ( rde * np . conj ( rde ) * ( - 1 ) ** ( self . f + fsum ) * np . sqrt ( 6 * self . f * ( 2 * self . f + 1 ) / ( self . f + 1 )) * wigner6j12 ( 1 , 1 , 1 , self . f , self . f , fsum ) * freq * ( 2 * fsum + 1 ) * self . wigner6j [ int ( level . j - 1 / 2 ), int ( self . f - abs ( self . state . j - self . I )), int ( fsum - 1 )] ** 2 ) tot = ( 1 / hbar ) * au ** 2 * tot / 2 return tot get_C3 ( self , material , state , units = 'SI' ) \u00b6 Method to compute C3 coefficient of Casimir-Polder interactions. The calculation assumes an infinite plane wall of the given material and with the atom defined by atomicsystem. A database for the refractive of a few materials is already implemented but you can add the one you want on the \"refractiveindexes\" folder. Parameters: Name Type Description Default material material required state atomiclevel Atomic level from which we want to compute C3. required units str,optional \"SI\" or \"au\" atomic units. Default is SI 'SI' Examples: >>> self . get_C3 ( self . structure . material , self . groundstate ) >>> 5.0093046822224805e-49 Source code in nanotrappy\\trapping\\atomicsystem.py def get_C3 ( self , material , state , units = \"SI\" ): \"\"\" Method to compute C3 coefficient of Casimir-Polder interactions. The calculation assumes an infinite plane wall of the given material and with the atom defined by atomicsystem. A database for the refractive of a few materials is already implemented but you can add the one you want on the \"refractiveindexes\" folder. Args: material (material): state (atomiclevel): Atomic level from which we want to compute C3. units (str,optional): \"SI\" or \"au\" atomic units. Default is SI Examples: >>>self.get_C3(self.structure.material,self.groundstate) >>>5.0093046822224805e-49 \"\"\" if str ( material . __class__ . __name__ ) != \"str\" : material = str ( material . __class__ . __name__ ) xi = np . logspace ( 1 , 18 , 400 , base = 10 ) # lambdalist = [(2*np.pi*cc)/k for k in xi] alphaim = self . alphaim0 ( state , xi ) * ( a0 ** 3 ) if material == \"metal\" : trap = [( xi [ k + 1 ] - xi [ k ]) * ( alphaim [ k ] + alphaim [ k + 1 ]) / 2 for k in range ( len ( xi ) - 1 )] else : n = np . load ( utils_path + r \"/refractiveindexes/\" + material + \".npy\" ) # these files contain 3 columns : lambda, Re(n), Im(n) # Imeps = 2*n[:,1]*n[:,2] Reeps = n [:, 1 ] ** 2 - n [:, 2 ] ** 2 omegalist = 2 * np . pi * cc / ( n [:, 0 ] * 1e-6 ) trap = np . zeros ( ( len ( omegalist ), len ( xi )) ) # If the extinction factor is 0, this expression has to be used instead of the standard one def integrand_real ( k , i ): return ( Reeps [ k ] - 1 ) * xi [ i ] / ( omegalist [ k ] ** 2 + xi [ i ] ** 2 ) def integrandC3 ( k ): return alphaim [ k ] * (( epsilontot [ k ] - 1 ) / ( epsilontot [ k ] + 1 )) for k in range ( len ( omegalist ) - 1 ): for i in range ( len ( xi )): trap [ k ][ i ] = ( ( omegalist [ k + 1 ] - omegalist [ k ]) * ( integrand_real ( k , i ) + integrand_real ( k + 1 , i )) / 2 ) I = np . sum ( trap , axis = 0 ) epsilontot = 1 + 2 / np . pi * ( - I ) trap = [( xi [ k + 1 ] - xi [ k ]) * ( integrandC3 ( k ) + integrandC3 ( k + 1 )) / 2 for k in range ( len ( xi ) - 1 )] if units == \"SI\" : C3 = hbar / ( 4 * np . pi ) * np . sum ( trap ) if units == \"au\" : C3 = hbar / (( 4 * np . pi ) * np . sum ( trap ) * ( a0 ** 3 * EH )) return C3 islower ( self , atlevel1 , atlevel2 ) \u00b6 This function checks if atlevel1 is lower in energy than atlevel2. Only used if one of atlevel1 or atlevel2 is either the ground or the excited state Parameters: Name Type Description Default atlevel1 atomiclevel atomic level. required atlevel2 atomiclevel atomic level. required Returns: Type Description bool True if successful, False otherwise. Examples: >>> syst . islower ( atomiclevel ( 5 , S , 1 / 2 ), atomiclevel ( 5 , P , 3 / 2 )) True Source code in nanotrappy\\trapping\\atomicsystem.py def islower ( self , atlevel1 , atlevel2 ): \"\"\"This function checks if atlevel1 is lower in energy than atlevel2. Only used if one of atlevel1 or atlevel2 is either the ground or the excited state Args: atlevel1 (atomiclevel): atomic level. atlevel2 (atomiclevel): atomic level. Returns: bool: True if successful, False otherwise. Example: >>> syst.islower(atomiclevel(5,S,1/2),atomiclevel(5,P,3/2)) True \"\"\" if atlevel2 == self . groundstate : return False elif atlevel2 == self . excitedstate : if atlevel1 == self . groundstate : return True else : return False potential ( self , Ep , Em , E0 ) \u00b6 This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Parameters: Name Type Description Default Ep float required Em float required E0 float required Returns: Type Description float Trapping potential for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def potential ( self , Ep , Em , E0 ): \"\"\"This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Args: Ep (float): Em (float): E0 (float): Returns: float: Trapping potential for the given parameters. \"\"\" Htemp = self . totalshift ( Ep , Em , E0 ) / ( mK * kB ) vals , vec = LA . eig ( Htemp ) idx = vals . argsort () return vals [ idx ], vec [ idx ] potential_partial ( self , Ep , Em , E0 , contrib = 'scalar' , show = False ) \u00b6 This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Parameters: Name Type Description Default Ep float required Em float required E0 float required Returns: Type Description float Trapping potential for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def potential_partial ( self , Ep , Em , E0 , contrib = \"scalar\" , show = False ): \"\"\"This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Args: Ep (float): Em (float): E0 (float): Returns: float: Trapping potential for the given parameters. \"\"\" if contrib == \"scalar\" : Htemp = self . scalarshift ( Ep , Em , E0 ) / ( mK * kB ) elif contrib == \"vector\" : Htemp = ( self . scalarshift ( Ep , Em , E0 ) + self . vectorshift ( Ep , Em , E0 )) / ( mK * kB ) elif contrib == \"tensor\" : Htemp = ( self . scalarshift ( Ep , Em , E0 ) + self . vectorshift ( Ep , Em , E0 ) + self . tensorshift ( Ep , Em , E0 )) / ( mK * kB ) else : raise ( ValueError ( \"This contribution does not exist.\" )) if show : print ( \" \\n \" . join ([ \" \\t \" . join ([ str ( 5e-3 * cell ) for cell in row ]) for row in Htemp ])) vals , vec = LA . eig ( Htemp ) idx = vals . argsort () return vals [ idx ], vec [ idx ] convert_to_float ( frac_str ) \u00b6 Source code in nanotrappy\\trapping\\atomicsystem.py def convert_to_float ( frac_str ): \"\"\"float: util function to convert string of fraction to float.\"\"\" try : return float ( frac_str ) except ValueError : num , denom = frac_str . split ( \"/\" ) try : leading , num = num . split ( \" \" ) whole = float ( leading ) except ValueError : whole = 0 frac = float ( num ) / float ( denom ) return whole - frac if whole < 0 else whole + frac string_to_level ( str ) \u00b6 Source code in nanotrappy\\trapping\\atomicsystem.py def string_to_level ( str ): \"\"\"atomiclevel: parse an input string into an atomic level object.\"\"\" j = convert_to_float ( str [ - 3 ::]) ltemp = str [ - 4 :: - 3 ] if ltemp == \"S\" : l = 0 elif ltemp == \"P\" : l = 1 elif ltemp == \"D\" : l = 2 elif ltemp == \"F\" : l = 3 elif ltemp == \"G\" : l = 4 else : raise \"Has not been implemented yet.\" n = int ( str [ 0 :: - 4 ]) return atomiclevel ( n , l , j )","title":"Atomic system"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem","text":"","title":"nanotrappy.trapping.atomicsystem"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomiclevel","text":"This is the class that implements the atomic levels. An atomiclevel object is used as a container for the three quantum numbers n, l and j of the considered level Note Some method to define an order between levels is implemented, even though it is not in use right now. Attributes: Name Type Description n int Principal quantum number. l int Azimuthal (orbital angular momentum) quantum number. j int or half-int) Total angular momentum quantum number. Examples: In order to create an atomic level, one can just write: >>> level = atomiclevel ( 6 , P , 1 / 2 ) >>> print ( level ) 6 P1 / 2","title":"atomiclevel"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomiclevel.__str__","text":"str : Formatted print of an atomic level, using the usual S, P, D... notation. Source code in nanotrappy\\trapping\\atomicsystem.py def __str__ ( self ): \"\"\"str : Formatted print of an atomic level, using the usual S, P, D... notation.\"\"\" if self . l == 0 : return str ( self . n ) + \"S\" + asfraction ( self . j ) elif self . l == 1 : return str ( self . n ) + \"P\" + asfraction ( self . j ) elif self . l == 2 : return str ( self . n ) + \"D\" + asfraction ( self . j )","title":"__str__()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem","text":"This is the class that implements the atomic system under study. It calls the ARC Rydberg calculator in the background to collect all the datas available for the chosen atom. All the information of the states to which the ground state and the excited state couple to are stored in a array of dictionnaries. dicoatom is the dictionnary for the selected state The coupled states are given by a triplet (n,l,j). Note Some method to define an order between levels is implemented, even though it is not in use right now. Attributes: Name Type Description atom atom The atom selected among ARC catalog (ex: Caesium(), Rubidium87()...). state atomiclevel The atomic level considered as the state of interest. f int Hyperfine level. Nground int the principal quantum number of the ground state (for computationnal use). listlevels list[atomiclevel] list of the atomic levels coupled to the state. dicoatom list[dict] dictionnary of the physical quantities, to avoid using ARC methods every time. Note The format of the dictionnaries is the following: To each atomic level is associated a triplet (f,rde,gamma) where f is the transition frequency to this level, rde is the reduced matrix element of the transition and gamma is the transition rate. Examples: An atomic system is created as follow: >>> atomic_system = atomicsystem ( Rubidium87 (), atomiclevel ( 5 , S , 1 / 2 ), f = 2 ) Additionnaly, a parser is provided so that the following is also valid: >>> atomic_system = atomicsystem ( Rubidium87 (), \"5S1/2\" , f = 2 )","title":"atomicsystem"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem.alpha_scalar","text":"This function returns the scalar polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Parameters: Name Type Description Default lmbda float Wavelength at which to compute the polarizability. required Returns: Type Description float Scalar polarizability for the given parameters. Examples: >>> syst . alpha0 ( 780e-9 ) / AMU - 329596.9660348868 Source code in nanotrappy\\trapping\\atomicsystem.py def alpha_scalar ( self , lmbda ): \"\"\"This function returns the scalar polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Args: lmbda (float): Wavelength at which to compute the polarizability. Returns: float: Scalar polarizability for the given parameters. Example: >>> syst.alpha0(780e-9)/AMU -329596.9660348868 \"\"\" if self . f > self . I + self . state . j or self . f < abs ( self . I - self . state . j ): raise ValueError ( \"F should be in the interval [|I-J|,I+J]\" ) tot = 0.0 freq = 0.0 sign = 1.0 coupledlevels = self . listlevels couplings = self . dicoatom for level in coupledlevels : c = couplings [( level . n , level . l , level . j )] gamma = c [ 2 ] omega = 2 * np . pi * c [ 0 ] rde = abs ( c [ 1 ]) freq = np . real ( 1 / ( sign * omega - ( 2 * np . pi * cc / lmbda ) - 1 j * gamma / 2 ) + 1 / ( sign * omega + ( 2 * np . pi * cc / lmbda ) + 1 j * gamma / 2 ) ) for fsum in np . arange ( abs ( level . j - self . I ), abs ( level . j + self . I ) + 1 , 1 ): tot += ( rde * np . conj ( rde ) * freq * ( 2 * fsum + 1 ) * ( self . wigner6j [ int ( level . j - 1 / 2 ), int ( self . f - abs ( self . state . j - self . I )), int ( fsum - 1 )]) ** 2 ) tot = ( 1 / ( 3 * hbar )) * au ** 2 * tot if self . state == self . groundstate : tot += self . alpha_core * AMU return tot","title":"alpha_scalar()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem.alpha_tensor","text":"This function returns the tensor polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Parameters: Name Type Description Default lmbda float Wavelength at which to compute the polarizability. required Returns: Type Description float Tensor polarizability for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def alpha_tensor ( self , lmbda ): \"\"\"This function returns the tensor polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Args: lmbda (float): Wavelength at which to compute the polarizability. Returns: float: Tensor polarizability for the given parameters. \"\"\" if self . f > self . I + self . state . j or self . f < abs ( self . I - self . state . j ): raise ValueError ( \"F should be in the interval [|I-J|,I+J]\" ) tot = 0.0 freq = 0.0 sign = 1.0 coupledlevels = self . listlevels couplings = self . dicoatom for level in coupledlevels : c = couplings [( level . n , level . l , level . j )] gamma = c [ 2 ] omega = 2 * np . pi * c [ 0 ] rde = abs ( c [ 1 ]) freq = np . real ( 1 / ( sign * omega - ( 2 * np . pi * cc / lmbda ) - 1 j * gamma / 2 ) + 1 / ( sign * omega + ( 2 * np . pi * cc / lmbda ) + 1 j * gamma / 2 ) ) for fsum in np . arange ( abs ( level . j - self . I ), abs ( level . j + self . I ) + 1 , 1 ): tot += ( rde * np . conj ( rde ) * ( - 1 ) ** ( self . f + fsum ) * np . sqrt ( 10 * self . f * ( 2 * self . f + 1 ) * ( 2 * self . f - 1 ) / ( 3 * ( self . f + 1 ) * ( 2 * self . f + 3 ))) * wigner6j12 ( 1 , 1 , 2 , self . f , self . f , fsum ) * freq * ( 2 * fsum + 1 ) * self . wigner6j [ int ( level . j - 1 / 2 ), int ( self . f - abs ( self . state . j - self . I )), int ( fsum - 1 )] ** 2 ) tot = ( 1 / ( hbar )) * au ** 2 * tot return tot","title":"alpha_tensor()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem.alpha_vector","text":"This function returns the vector polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Parameters: Name Type Description Default lmbda float Wavelength at which to compute the polarizability. required Returns: Type Description float Vector polarizability for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def alpha_vector ( self , lmbda ): \"\"\"This function returns the vector polarizability of the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this contribution is calculated is available in the main documentation. Args: lmbda (float): Wavelength at which to compute the polarizability. Returns: float: Vector polarizability for the given parameters. \"\"\" if self . f > self . I + self . state . j or self . f < abs ( self . I - self . state . j ): raise ValueError ( \"F should be in the interval [|I-J|,I+J]\" ) tot = 0.0 freq = 0.0 sign = 1.0 coupledlevels = self . listlevels couplings = self . dicoatom for level in coupledlevels : c = couplings [( level . n , level . l , level . j )] gamma = c [ 2 ] omega = 2 * np . pi * c [ 0 ] rde = abs ( c [ 1 ]) freq = np . real ( 1 / ( sign * omega - ( 2 * np . pi * cc / lmbda ) - 1 j * gamma / 2 ) - 1 / ( sign * omega + ( 2 * np . pi * cc / lmbda ) + 1 j * gamma / 2 ) ) for fsum in np . arange ( abs ( level . j - self . I ), abs ( level . j + self . I ) + 1 , 1 ): tot += ( rde * np . conj ( rde ) * ( - 1 ) ** ( self . f + fsum ) * np . sqrt ( 6 * self . f * ( 2 * self . f + 1 ) / ( self . f + 1 )) * wigner6j12 ( 1 , 1 , 1 , self . f , self . f , fsum ) * freq * ( 2 * fsum + 1 ) * self . wigner6j [ int ( level . j - 1 / 2 ), int ( self . f - abs ( self . state . j - self . I )), int ( fsum - 1 )] ** 2 ) tot = ( 1 / hbar ) * au ** 2 * tot / 2 return tot","title":"alpha_vector()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem.get_C3","text":"Method to compute C3 coefficient of Casimir-Polder interactions. The calculation assumes an infinite plane wall of the given material and with the atom defined by atomicsystem. A database for the refractive of a few materials is already implemented but you can add the one you want on the \"refractiveindexes\" folder. Parameters: Name Type Description Default material material required state atomiclevel Atomic level from which we want to compute C3. required units str,optional \"SI\" or \"au\" atomic units. Default is SI 'SI' Examples: >>> self . get_C3 ( self . structure . material , self . groundstate ) >>> 5.0093046822224805e-49 Source code in nanotrappy\\trapping\\atomicsystem.py def get_C3 ( self , material , state , units = \"SI\" ): \"\"\" Method to compute C3 coefficient of Casimir-Polder interactions. The calculation assumes an infinite plane wall of the given material and with the atom defined by atomicsystem. A database for the refractive of a few materials is already implemented but you can add the one you want on the \"refractiveindexes\" folder. Args: material (material): state (atomiclevel): Atomic level from which we want to compute C3. units (str,optional): \"SI\" or \"au\" atomic units. Default is SI Examples: >>>self.get_C3(self.structure.material,self.groundstate) >>>5.0093046822224805e-49 \"\"\" if str ( material . __class__ . __name__ ) != \"str\" : material = str ( material . __class__ . __name__ ) xi = np . logspace ( 1 , 18 , 400 , base = 10 ) # lambdalist = [(2*np.pi*cc)/k for k in xi] alphaim = self . alphaim0 ( state , xi ) * ( a0 ** 3 ) if material == \"metal\" : trap = [( xi [ k + 1 ] - xi [ k ]) * ( alphaim [ k ] + alphaim [ k + 1 ]) / 2 for k in range ( len ( xi ) - 1 )] else : n = np . load ( utils_path + r \"/refractiveindexes/\" + material + \".npy\" ) # these files contain 3 columns : lambda, Re(n), Im(n) # Imeps = 2*n[:,1]*n[:,2] Reeps = n [:, 1 ] ** 2 - n [:, 2 ] ** 2 omegalist = 2 * np . pi * cc / ( n [:, 0 ] * 1e-6 ) trap = np . zeros ( ( len ( omegalist ), len ( xi )) ) # If the extinction factor is 0, this expression has to be used instead of the standard one def integrand_real ( k , i ): return ( Reeps [ k ] - 1 ) * xi [ i ] / ( omegalist [ k ] ** 2 + xi [ i ] ** 2 ) def integrandC3 ( k ): return alphaim [ k ] * (( epsilontot [ k ] - 1 ) / ( epsilontot [ k ] + 1 )) for k in range ( len ( omegalist ) - 1 ): for i in range ( len ( xi )): trap [ k ][ i ] = ( ( omegalist [ k + 1 ] - omegalist [ k ]) * ( integrand_real ( k , i ) + integrand_real ( k + 1 , i )) / 2 ) I = np . sum ( trap , axis = 0 ) epsilontot = 1 + 2 / np . pi * ( - I ) trap = [( xi [ k + 1 ] - xi [ k ]) * ( integrandC3 ( k ) + integrandC3 ( k + 1 )) / 2 for k in range ( len ( xi ) - 1 )] if units == \"SI\" : C3 = hbar / ( 4 * np . pi ) * np . sum ( trap ) if units == \"au\" : C3 = hbar / (( 4 * np . pi ) * np . sum ( trap ) * ( a0 ** 3 * EH )) return C3","title":"get_C3()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem.islower","text":"This function checks if atlevel1 is lower in energy than atlevel2. Only used if one of atlevel1 or atlevel2 is either the ground or the excited state Parameters: Name Type Description Default atlevel1 atomiclevel atomic level. required atlevel2 atomiclevel atomic level. required Returns: Type Description bool True if successful, False otherwise. Examples: >>> syst . islower ( atomiclevel ( 5 , S , 1 / 2 ), atomiclevel ( 5 , P , 3 / 2 )) True Source code in nanotrappy\\trapping\\atomicsystem.py def islower ( self , atlevel1 , atlevel2 ): \"\"\"This function checks if atlevel1 is lower in energy than atlevel2. Only used if one of atlevel1 or atlevel2 is either the ground or the excited state Args: atlevel1 (atomiclevel): atomic level. atlevel2 (atomiclevel): atomic level. Returns: bool: True if successful, False otherwise. Example: >>> syst.islower(atomiclevel(5,S,1/2),atomiclevel(5,P,3/2)) True \"\"\" if atlevel2 == self . groundstate : return False elif atlevel2 == self . excitedstate : if atlevel1 == self . groundstate : return True else : return False","title":"islower()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem.potential","text":"This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Parameters: Name Type Description Default Ep float required Em float required E0 float required Returns: Type Description float Trapping potential for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def potential ( self , Ep , Em , E0 ): \"\"\"This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Args: Ep (float): Em (float): E0 (float): Returns: float: Trapping potential for the given parameters. \"\"\" Htemp = self . totalshift ( Ep , Em , E0 ) / ( mK * kB ) vals , vec = LA . eig ( Htemp ) idx = vals . argsort () return vals [ idx ], vec [ idx ]","title":"potential()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.atomicsystem.potential_partial","text":"This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Parameters: Name Type Description Default Ep float required Em float required E0 float required Returns: Type Description float Trapping potential for the given parameters. Source code in nanotrappy\\trapping\\atomicsystem.py def potential_partial ( self , Ep , Em , E0 , contrib = \"scalar\" , show = False ): \"\"\"This function computes the trapping potential energy for a given electric field and the given state and hyperfine state F of the atom, at the wavelength lambda. Documentation on how this potential is calculated is available in the main documentation. Args: Ep (float): Em (float): E0 (float): Returns: float: Trapping potential for the given parameters. \"\"\" if contrib == \"scalar\" : Htemp = self . scalarshift ( Ep , Em , E0 ) / ( mK * kB ) elif contrib == \"vector\" : Htemp = ( self . scalarshift ( Ep , Em , E0 ) + self . vectorshift ( Ep , Em , E0 )) / ( mK * kB ) elif contrib == \"tensor\" : Htemp = ( self . scalarshift ( Ep , Em , E0 ) + self . vectorshift ( Ep , Em , E0 ) + self . tensorshift ( Ep , Em , E0 )) / ( mK * kB ) else : raise ( ValueError ( \"This contribution does not exist.\" )) if show : print ( \" \\n \" . join ([ \" \\t \" . join ([ str ( 5e-3 * cell ) for cell in row ]) for row in Htemp ])) vals , vec = LA . eig ( Htemp ) idx = vals . argsort () return vals [ idx ], vec [ idx ]","title":"potential_partial()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.convert_to_float","text":"Source code in nanotrappy\\trapping\\atomicsystem.py def convert_to_float ( frac_str ): \"\"\"float: util function to convert string of fraction to float.\"\"\" try : return float ( frac_str ) except ValueError : num , denom = frac_str . split ( \"/\" ) try : leading , num = num . split ( \" \" ) whole = float ( leading ) except ValueError : whole = 0 frac = float ( num ) / float ( denom ) return whole - frac if whole < 0 else whole + frac","title":"convert_to_float()"},{"location":"reference/atomicsystem/#nanotrappy.trapping.atomicsystem.string_to_level","text":"Source code in nanotrappy\\trapping\\atomicsystem.py def string_to_level ( str ): \"\"\"atomiclevel: parse an input string into an atomic level object.\"\"\" j = convert_to_float ( str [ - 3 ::]) ltemp = str [ - 4 :: - 3 ] if ltemp == \"S\" : l = 0 elif ltemp == \"P\" : l = 1 elif ltemp == \"D\" : l = 2 elif ltemp == \"F\" : l = 3 elif ltemp == \"G\" : l = 4 else : raise \"Has not been implemented yet.\" n = int ( str [ 0 :: - 4 ]) return atomiclevel ( n , l , j )","title":"string_to_level()"},{"location":"reference/beam/","text":"\u00b6 Beam \u00b6 This is the subclass that implements a single beam. Attributes: Name Type Description lmbda float wavelength of the beam (m) direction string direction of the Beam. \"f\" for a forward beam, \"b\" for a bacward propagating beam. power float power of the beam (W) Note The direction here is not used in the program, but we found it useful to keep in mind the physical system under study. Examples: To create an instance of the Beam class: >>> BP = Beam ( 852e-9 , \"f\" , 1 * mW ) get_direction ( self ) \u00b6 Getter function for the direction attribute Returns: Type Description str direction of the beam Source code in nanotrappy\\trapping\\beam.py def get_direction ( self ): \"\"\"Getter function for the direction attribute Returns: str: direction of the beam \"\"\" return self . direction get_lmbda ( self ) \u00b6 Getter function for the lmbda attribute Returns: Type Description float wavelength of the beam Source code in nanotrappy\\trapping\\beam.py def get_lmbda ( self ): \"\"\"Getter function for the lmbda attribute Returns: float: wavelength of the beam \"\"\" return self . lmbda get_power ( self ) \u00b6 Getter function for the power attribute Returns: Type Description float power of the beam Source code in nanotrappy\\trapping\\beam.py def get_power ( self ): \"\"\"Getter function for the power attribute Returns: float: power of the beam \"\"\" return self . power set_direction ( self , direction ) \u00b6 Set the direction attribute of the beam. Parameters: Name Type Description Default direction str new direction to be set. required Source code in nanotrappy\\trapping\\beam.py def set_direction ( self , direction ): \"\"\"Set the direction attribute of the beam. Args: direction (str): new direction to be set. \"\"\" self . direction = direction set_lmbda ( self , lmbda ) \u00b6 Set the wavelength attribute of the beam. Parameters: Name Type Description Default lmbda float new wavelength to be set (m) required Source code in nanotrappy\\trapping\\beam.py def set_lmbda ( self , lmbda ): \"\"\"Set the wavelength attribute of the beam. Args: lmbda (float): new wavelength to be set (m) \"\"\" self . lmbda = lmbda set_power ( self , power ) \u00b6 Set the power attribute of the beam. Parameters: Name Type Description Default power float new power to be set (W) required Source code in nanotrappy\\trapping\\beam.py def set_power ( self , power ): \"\"\"Set the power attribute of the beam. Args: power (float): new power to be set (W) \"\"\" self . power = power BeamPair \u00b6 This is the subclass that implements a single beam. Attributes: Name Type Description lmbda1 float wavelength of the first beam of the pair (m) power1 float power of the first beam of the pair (W) lmbda2 float wavelength of the second beam of the pair (m) power2 float power of the second beam of the pair (W) Caution Here the powers have to be the same for now. It would considerably slow the computation if not. We still put two args to mimic the physical system. We hope it will be implemented in the future. Caution The wavelengths do not have to be the same, but in the spirit of the current research, we limit the possible difference. This boundary wavelength_equality_tolerance can be modified if need in the utils.utils module. Exceptions: Type Description ValueError if power1 not equal to power 2 ValueError if |lmbda1-lmbda2| > wavelength_equality_tolerance Examples: To create an instance of the BeamPair class: >>> BP = BeamPair ( 852e-9 , \"f\" , 1 * mW , 852e-9 , \"f\" , 1 * mW ) get_lmbda ( self ) \u00b6 Get the wavelengths of a BeamPair Returns: Type Description array an array of the two wavelengths Source code in nanotrappy\\trapping\\beam.py def get_lmbda ( self ): \"\"\"Get the wavelengths of a BeamPair Returns: array: an array of the two wavelengths \"\"\" return np . array ([ self . beam1 . lmbda , self . beam2 . lmbda ]) get_power ( self ) \u00b6 Get the powers of a BeamPair Returns: Type Description float power of the two beams Caution As the two powers have to be equal, this functions returns only one float. Source code in nanotrappy\\trapping\\beam.py def get_power ( self ): \"\"\"Get the powers of a BeamPair Returns: float: power of the two beams Caution: As the two powers have to be equal, this functions returns only one float. \"\"\" return self . beam1 . power set_lmbda ( self , * args ) \u00b6 Set the wavelengths of a BeamPair If a list is provided, the wavelengths are set idependently using this list. If a float is provided, the two wavelengths are set to be equal. Parameters: Name Type Description Default lmbdas float either a list of two values, or one value (m) required Exceptions: Type Description ValueError if |lmbda1-lmbda2| > wavelength_equality_tolerance ValueError if more than 2 wavelengths are provided Source code in nanotrappy\\trapping\\beam.py def set_lmbda ( self , * args ): \"\"\"Set the wavelengths of a BeamPair If a list is provided, the wavelengths are set idependently using this list. If a float is provided, the two wavelengths are set to be equal. Args: lmbdas (float): either a list of two values, or one value (m) Raise: ValueError: if |lmbda1-lmbda2| > wavelength_equality_tolerance ValueError: if more than 2 wavelengths are provided \"\"\" if len ( args ) == 1 : self . beam1 . lmbda = args [ 0 ] self . beam2 . lmbda = args [ 0 ] elif len ( args ) == 2 : if abs ( args [ 0 ] - args [ 1 ]) < pu . wavelength_equality_tolerance : self . beam1 . lmbda = args [ 0 ] self . beam2 . lmbda = args [ 1 ] else : raise ValueError ( 'Cannot set different values of wavelengths for a pair of beams.' ) else : raise ValueError ( \"Too many values to unpack\" ) set_power ( self , power ) \u00b6 Set the powers of a BeamPair Only one power is needed as the powers have to be the same. Parameters: Name Type Description Default power float new power to be set for the two beams (W) required Source code in nanotrappy\\trapping\\beam.py def set_power ( self , power ): \"\"\"Set the powers of a BeamPair Only one power is needed as the powers have to be the same. Args: power (float): new power to be set for the two beams (W) \"\"\" self . beam1 . power = power self . beam2 . power = power Beams \u00b6 This is the parent class that implements the beams. It is used to define the general tests to distinguish between a Beam and a BeamPair. Examples: To test if a object object of type Beams is an instance of the subclass BeamPair: >>> BP = BeamPair ( 852e-9 , 1 * mW , 852e-9 , 1 * mW ) >>> BP . isBeam () False >>> BP . isBeamPair () True isBeam ( self ) \u00b6 Checks if a Beams object is an instance of the Beam subclass. Returns: Type Description bool True if the object is an instance of the Beam subclass Source code in nanotrappy\\trapping\\beam.py def isBeam ( self ): \"\"\"Checks if a Beams object is an instance of the Beam subclass. Returns: bool: True if the object is an instance of the Beam subclass \"\"\" if type ( self ) . __name__ == \"Beam\" : return True else : return False isBeamPair ( self ) \u00b6 Checks if a Beams object is an instance of the BeamPair subclass. Returns: Type Description bool True if the object is an instance of the BeamPair subclass Source code in nanotrappy\\trapping\\beam.py def isBeamPair ( self ): \"\"\"Checks if a Beams object is an instance of the BeamPair subclass. Returns: bool: True if the object is an instance of the BeamPair subclass \"\"\" if type ( self ) . __name__ == \"BeamPair\" : return True else : return False","title":"Beam"},{"location":"reference/beam/#nanotrappy.trapping.beam","text":"","title":"nanotrappy.trapping.beam"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beam","text":"This is the subclass that implements a single beam. Attributes: Name Type Description lmbda float wavelength of the beam (m) direction string direction of the Beam. \"f\" for a forward beam, \"b\" for a bacward propagating beam. power float power of the beam (W) Note The direction here is not used in the program, but we found it useful to keep in mind the physical system under study. Examples: To create an instance of the Beam class: >>> BP = Beam ( 852e-9 , \"f\" , 1 * mW )","title":"Beam"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beam.get_direction","text":"Getter function for the direction attribute Returns: Type Description str direction of the beam Source code in nanotrappy\\trapping\\beam.py def get_direction ( self ): \"\"\"Getter function for the direction attribute Returns: str: direction of the beam \"\"\" return self . direction","title":"get_direction()"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beam.get_lmbda","text":"Getter function for the lmbda attribute Returns: Type Description float wavelength of the beam Source code in nanotrappy\\trapping\\beam.py def get_lmbda ( self ): \"\"\"Getter function for the lmbda attribute Returns: float: wavelength of the beam \"\"\" return self . lmbda","title":"get_lmbda()"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beam.get_power","text":"Getter function for the power attribute Returns: Type Description float power of the beam Source code in nanotrappy\\trapping\\beam.py def get_power ( self ): \"\"\"Getter function for the power attribute Returns: float: power of the beam \"\"\" return self . power","title":"get_power()"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beam.set_direction","text":"Set the direction attribute of the beam. Parameters: Name Type Description Default direction str new direction to be set. required Source code in nanotrappy\\trapping\\beam.py def set_direction ( self , direction ): \"\"\"Set the direction attribute of the beam. Args: direction (str): new direction to be set. \"\"\" self . direction = direction","title":"set_direction()"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beam.set_lmbda","text":"Set the wavelength attribute of the beam. Parameters: Name Type Description Default lmbda float new wavelength to be set (m) required Source code in nanotrappy\\trapping\\beam.py def set_lmbda ( self , lmbda ): \"\"\"Set the wavelength attribute of the beam. Args: lmbda (float): new wavelength to be set (m) \"\"\" self . lmbda = lmbda","title":"set_lmbda()"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beam.set_power","text":"Set the power attribute of the beam. Parameters: Name Type Description Default power float new power to be set (W) required Source code in nanotrappy\\trapping\\beam.py def set_power ( self , power ): \"\"\"Set the power attribute of the beam. Args: power (float): new power to be set (W) \"\"\" self . power = power","title":"set_power()"},{"location":"reference/beam/#nanotrappy.trapping.beam.BeamPair","text":"This is the subclass that implements a single beam. Attributes: Name Type Description lmbda1 float wavelength of the first beam of the pair (m) power1 float power of the first beam of the pair (W) lmbda2 float wavelength of the second beam of the pair (m) power2 float power of the second beam of the pair (W) Caution Here the powers have to be the same for now. It would considerably slow the computation if not. We still put two args to mimic the physical system. We hope it will be implemented in the future. Caution The wavelengths do not have to be the same, but in the spirit of the current research, we limit the possible difference. This boundary wavelength_equality_tolerance can be modified if need in the utils.utils module. Exceptions: Type Description ValueError if power1 not equal to power 2 ValueError if |lmbda1-lmbda2| > wavelength_equality_tolerance Examples: To create an instance of the BeamPair class: >>> BP = BeamPair ( 852e-9 , \"f\" , 1 * mW , 852e-9 , \"f\" , 1 * mW )","title":"BeamPair"},{"location":"reference/beam/#nanotrappy.trapping.beam.BeamPair.get_lmbda","text":"Get the wavelengths of a BeamPair Returns: Type Description array an array of the two wavelengths Source code in nanotrappy\\trapping\\beam.py def get_lmbda ( self ): \"\"\"Get the wavelengths of a BeamPair Returns: array: an array of the two wavelengths \"\"\" return np . array ([ self . beam1 . lmbda , self . beam2 . lmbda ])","title":"get_lmbda()"},{"location":"reference/beam/#nanotrappy.trapping.beam.BeamPair.get_power","text":"Get the powers of a BeamPair Returns: Type Description float power of the two beams Caution As the two powers have to be equal, this functions returns only one float. Source code in nanotrappy\\trapping\\beam.py def get_power ( self ): \"\"\"Get the powers of a BeamPair Returns: float: power of the two beams Caution: As the two powers have to be equal, this functions returns only one float. \"\"\" return self . beam1 . power","title":"get_power()"},{"location":"reference/beam/#nanotrappy.trapping.beam.BeamPair.set_lmbda","text":"Set the wavelengths of a BeamPair If a list is provided, the wavelengths are set idependently using this list. If a float is provided, the two wavelengths are set to be equal. Parameters: Name Type Description Default lmbdas float either a list of two values, or one value (m) required Exceptions: Type Description ValueError if |lmbda1-lmbda2| > wavelength_equality_tolerance ValueError if more than 2 wavelengths are provided Source code in nanotrappy\\trapping\\beam.py def set_lmbda ( self , * args ): \"\"\"Set the wavelengths of a BeamPair If a list is provided, the wavelengths are set idependently using this list. If a float is provided, the two wavelengths are set to be equal. Args: lmbdas (float): either a list of two values, or one value (m) Raise: ValueError: if |lmbda1-lmbda2| > wavelength_equality_tolerance ValueError: if more than 2 wavelengths are provided \"\"\" if len ( args ) == 1 : self . beam1 . lmbda = args [ 0 ] self . beam2 . lmbda = args [ 0 ] elif len ( args ) == 2 : if abs ( args [ 0 ] - args [ 1 ]) < pu . wavelength_equality_tolerance : self . beam1 . lmbda = args [ 0 ] self . beam2 . lmbda = args [ 1 ] else : raise ValueError ( 'Cannot set different values of wavelengths for a pair of beams.' ) else : raise ValueError ( \"Too many values to unpack\" )","title":"set_lmbda()"},{"location":"reference/beam/#nanotrappy.trapping.beam.BeamPair.set_power","text":"Set the powers of a BeamPair Only one power is needed as the powers have to be the same. Parameters: Name Type Description Default power float new power to be set for the two beams (W) required Source code in nanotrappy\\trapping\\beam.py def set_power ( self , power ): \"\"\"Set the powers of a BeamPair Only one power is needed as the powers have to be the same. Args: power (float): new power to be set for the two beams (W) \"\"\" self . beam1 . power = power self . beam2 . power = power","title":"set_power()"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beams","text":"This is the parent class that implements the beams. It is used to define the general tests to distinguish between a Beam and a BeamPair. Examples: To test if a object object of type Beams is an instance of the subclass BeamPair: >>> BP = BeamPair ( 852e-9 , 1 * mW , 852e-9 , 1 * mW ) >>> BP . isBeam () False >>> BP . isBeamPair () True","title":"Beams"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beams.isBeam","text":"Checks if a Beams object is an instance of the Beam subclass. Returns: Type Description bool True if the object is an instance of the Beam subclass Source code in nanotrappy\\trapping\\beam.py def isBeam ( self ): \"\"\"Checks if a Beams object is an instance of the Beam subclass. Returns: bool: True if the object is an instance of the Beam subclass \"\"\" if type ( self ) . __name__ == \"Beam\" : return True else : return False","title":"isBeam()"},{"location":"reference/beam/#nanotrappy.trapping.beam.Beams.isBeamPair","text":"Checks if a Beams object is an instance of the BeamPair subclass. Returns: Type Description bool True if the object is an instance of the BeamPair subclass Source code in nanotrappy\\trapping\\beam.py def isBeamPair ( self ): \"\"\"Checks if a Beams object is an instance of the BeamPair subclass. Returns: bool: True if the object is an instance of the BeamPair subclass \"\"\" if type ( self ) . __name__ == \"BeamPair\" : return True else : return False","title":"isBeamPair()"},{"location":"reference/simulation/","text":"\u00b6 Simulation \u00b6 Simulation class. Bundle of all the predefined objects that are needed for computing the potentials. Attributes: Name Type Description atomic system (atomicsytem Atomic system that we want to trap (has an atom and a hyperfine level as attributes among others) material material See NanoTrap.utils.materials for available materials. They can be easily added by the user. trap trap trap object with the beams used for the specified trap scheme. surface surface Plane or Cylinder, to get a local mask for the CP interaction (always computed as -C3/r**3). data_folder str Folder where your modes with the right formatting are saved. The class will fetch the modes corresponding to the trap in this folder (if they exist). lmbdas_modes property readonly \u00b6 Returns a list of all the wavelengths available in the modes present in the data folder Note Passed as property so it is updated anytime the trap is changed exists_in_past_simulations ( self ) \u00b6 This method checks if the simulation about to be run has already been saved in the \"simulations\" folder, by checking the .json parameter files. Returns: Type Description (tuple) tuple containing: - bool : True if simulation already exists, False otherwise. - str : Name of the file if the simulation has already been run. Source code in nanotrappy\\trapping\\simulation.py def exists_in_past_simulations ( self ): \"\"\"This method checks if the simulation about to be run has already been saved in the \"simulations\" folder, by checking the .json parameter files. Returns: (tuple): tuple containing: - bool : True if simulation already exists, False otherwise. - str : Name of the file if the simulation has already been run. \"\"\" self . set_current_params () try : os . listdir ( self . data_folder + \"/simulations\" ) except FileNotFoundError : os . mkdir ( self . data_folder + \"/simulations\" ) for file in os . listdir ( self . data_folder + \"/simulations\" ): if file . endswith ( \".json\" ): with open ( self . data_folder + \"/simulations/\" + file ) as json_file : params = json . load ( json_file ) # initializing compare keys comp_keys = [ \"Atomic system\" , \"Material\" , \"Trap wavelengths\" , \"Considered state\" , \"Geometry\" , \"Surface\" ] # Compare Dictionaries on certain keys using all() res = all ( params . get ( key ) == self . params . get ( key ) for key in comp_keys ) if res : self . data_file = file [: - 4 ] + \"npy\" self . E_file = file [: - 5 ] + \"E_field.npy\" self . vecs_file = file [: - 5 ] + \"vecs.npy\" return True return False save ( self ) \u00b6 Saves both the parameters dictionnary into a .json file and the potentials attribute into a .npy. Source code in nanotrappy\\trapping\\simulation.py def save ( self ): \"\"\"Saves both the parameters dictionnary into a .json file and the potentials attribute into a .npy.\"\"\" if not self . already_saved : current_time = self . params [ \"Time of simulation\" ] current_time = current_time . replace ( \"/\" , \"_\" ) current_time = current_time . replace ( \":\" , \"_\" ) current_time = current_time . replace ( \" \" , \"_\" ) filename_params = self . data_folder + \"/simulations/\" + str ( current_time ) + \".json\" filename_data = self . data_folder + \"/simulations/\" + str ( current_time ) + \".npy\" E_filename_data = self . data_folder + \"/simulations/\" + str ( current_time ) + \"E_field.npy\" vecs_filename_data = self . data_folder + \"/simulations/\" + str ( current_time ) + \"vecs.npy\" if not os . path . exists ( os . path . dirname ( filename_params )): try : os . makedirs ( os . path . dirname ( filename_params )) except OSError as exc : # Guard against race condition if exc . errno != errno . EEXIST : raise with open ( filename_params , \"w\" ) as fp : json . dump ( self . params , fp ) np . save ( filename_data , self . potentials ) np . save ( E_filename_data , self . Etot ) np . save ( vecs_filename_data , self . vecs ) self . already_saved = True else : print ( \"This simulation has already been saved, see %s \" % ( self . data_file )) set_current_params ( self ) \u00b6 Sets a dictionnary with all the relevant parameters of the Simulation object and returns it. Returns: Type Description dict parameters of the simulation Source code in nanotrappy\\trapping\\simulation.py def set_current_params ( self ): \"\"\"Sets a dictionnary with all the relevant parameters of the Simulation object and returns it. Returns: dict : parameters of the simulation \"\"\" self . lmbdas_params = np . array ([]) self . P_params = np . array ([]) for ( k , beam ) in enumerate ( self . trap . beams ): self . lmbdas_params = np . append ( self . lmbdas_params , beam . get_lmbda ()) self . P_params = np . append ( self . P_params , beam . get_power ()) self . lmbdas_params . resize ( 2 * ( k + 1 ), refcheck = False ) self . P_params . resize ( 2 * ( k + 1 ), refcheck = False ) self . lmbdas_params . resize ( 4 , refcheck = False ) self . P_params . resize ( 4 , refcheck = False ) lambda1pair1 = str ( self . lmbdas_params [ 0 ] / nm ) + \" nm\" power1pair1 = str ( self . P_params [ 0 ] / mW ) + \" mW\" lambda2pair1 = str ( self . lmbdas_params [ 1 ] / nm ) + \" nm\" power2pair1 = str ( self . P_params [ 1 ] / mW ) + \" mW\" lambda1pair2 = str ( self . lmbdas_params [ 2 ] / nm ) + \" nm\" power1pair2 = str ( self . P_params [ 2 ] / mW ) + \" mW\" lambda2pair2 = str ( self . lmbdas_params [ 3 ] / nm ) + \" nm\" power2pair2 = str ( self . P_params [ 3 ] / mW ) + \" mW\" now = datetime . now () current_time = now . strftime ( \" %d /%m/%Y %H:%M:%S\" ) self . params = { \"Time of simulation\" : current_time , \"Atomic system\" : { \"species\" : type ( self . atomicsystem . atom ) . __name__ , \"groundstate\" : str ( self . atomicsystem . groundstate ), \"hyperfine level\" : int ( self . atomicsystem . f ), }, \"Material\" : str ( self . material ), \"Trap wavelengths\" : { \"lambda 1 pair 1\" : lambda1pair1 , \"lambda 2 pair 1\" : lambda2pair1 , \"lambda 1 pair 2\" : lambda1pair2 , \"lambda 2 pair 2\" : lambda2pair2 , }, \"Trap powers\" : { \"power 1 pair 1\" : power1pair1 , \"power 2 pair 1\" : power2pair1 , \"power 1 pair 2\" : power1pair2 , \"power 2 pair 2\" : power2pair2 , }, \"Considered state\" : str ( self . atomicsystem . state ), \"Geometry\" : { \"2D\" : self . geometry . dimension == 2 , \"2D plane\" : self . geometry . name if self . geometry . isPlane () else None , \"2D orthogonal coord\" : self . geometry . normal_coord if self . geometry . isPlane () else None , \"1D\" : self . geometry . dimension == 1 , \"1D axis\" : self . geometry . name if self . geometry . isAxis () else None , \"1D coord1\" : self . geometry . coordinates [ 0 ] if self . geometry . isAxis () else None , \"1D coord2\" : self . geometry . coordinates [ 1 ] if self . geometry . isAxis () else None , }, \"Surface\" : [ surface . params for surface in self . surface ], \"Data_folder\" : self . data_folder , } print ( \"[INFO] Simulation parameters set\" ) return self . params set_wavelengths_indices ( self ) \u00b6 Compares the wavelengths of the beams specified for the trap with the wavelengths of the available modes in the data folder and returns the list of the file indices that correspond. The wavelengths are rounded to 0.01 nm before comparison. !!! note Passed as property so it is updated anytime the trap is changed !!! raises ValueError: If at least one wavelength wanted for the trap cannot be found in the data folder. Source code in nanotrappy\\trapping\\simulation.py def set_wavelengths_indices ( self ): \"\"\"Compares the wavelengths of the beams specified for the trap with the wavelengths of the available modes in the data folder and returns the list of the file indices that correspond. The wavelengths are rounded to 0.01 nm before comparison. Note: Passed as property so it is updated anytime the trap is changed Raises: ValueError: If at least one wavelength wanted for the trap cannot be found in the data folder. \"\"\" self . wavelengths_indices = np . array ([], dtype = int ) for elem in self . trap . lmbdas : idx = np . where ( np . isclose ( self . lmbdas_modes , elem , atol = 1e-11 )) if len ( idx [ 0 ]) != 0 : self . wavelengths_indices = np . append ( self . wavelengths_indices , idx ) else : raise ValueError ( \"Demanded wavelengths for trap not found in data folder, the possible wavelengths are the following: \" , np . sort ( self . lmbdas_modes ), ) total_potential ( self ) \u00b6 Uses the potentials attributes of the Simulation object for each beam to return their weighted sum with the specified powers Returns: Type Description total potential array with shape(length coordinate 1,length coordinate 2,number of possbile mf states) Source code in nanotrappy\\trapping\\simulation.py def total_potential ( self ): \"\"\"Uses the potentials attributes of the Simulation object for each beam to return their weighted sum with the specified powers Returns: total potential : array with shape(length coordinate 1,length coordinate 2,number of possbile mf states) \"\"\" self . total_potential_noCP = np . zeros ( np . shape ( self . potentials [ 0 ]), dtype = \"float\" ) self . total_vecs = np . zeros ( np . shape ( self . vecs [ 0 ]), dtype = \"complex\" ) for ( i , potential ) in enumerate ( self . potentials ): self . total_potential_noCP = self . total_potential_noCP + self . trap . beams [ i ] . get_power () * potential self . total_vecs = self . trap . beams [ i ] . get_power () * self . vecs [ i ] norm_total_vecs = np . linalg . norm ( self . total_vecs , axis =- 1 ) number_mf_levels = self . total_vecs . shape [ - 1 ] for m in range ( number_mf_levels ): self . total_vecs [ ... , m ] /= norm_total_vecs return self . total_potential_noCP + np . dstack ([ self . CP ] * number_mf_levels ) parse_lmbdas ( data_folder ) \u00b6 This function opens all the .npy file of the given data_folder and stores the wavelengths of the modes in an array. Parameters: Name Type Description Default data_folder str Absolute path of the folder containing the computed available modes. required Returns: Type Description array np array with all the available wavelengths. Source code in nanotrappy\\trapping\\simulation.py def parse_lmbdas ( data_folder ): \"\"\"This function opens all the .npy file of the given data_folder and stores the wavelengths of the modes in an array. Args: data_folder (str): Absolute path of the folder containing the computed available modes. Returns: array : np array with all the available wavelengths. \"\"\" lmbdas_modes = np . array ([]) files = np . array ([ f for f in os . listdir ( data_folder ) if f . endswith ( \".npy\" )]) for filename in files : l = np . load ( data_folder + \"//\" + filename , allow_pickle = True )[ 0 ] lmbdas_modes = np . append ( lmbdas_modes , l ) return lmbdas_modes","title":"Simulation"},{"location":"reference/simulation/#nanotrappy.trapping.simulation","text":"","title":"nanotrappy.trapping.simulation"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.Simulation","text":"Simulation class. Bundle of all the predefined objects that are needed for computing the potentials. Attributes: Name Type Description atomic system (atomicsytem Atomic system that we want to trap (has an atom and a hyperfine level as attributes among others) material material See NanoTrap.utils.materials for available materials. They can be easily added by the user. trap trap trap object with the beams used for the specified trap scheme. surface surface Plane or Cylinder, to get a local mask for the CP interaction (always computed as -C3/r**3). data_folder str Folder where your modes with the right formatting are saved. The class will fetch the modes corresponding to the trap in this folder (if they exist).","title":"Simulation"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.Simulation.lmbdas_modes","text":"Returns a list of all the wavelengths available in the modes present in the data folder Note Passed as property so it is updated anytime the trap is changed","title":"lmbdas_modes"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.Simulation.exists_in_past_simulations","text":"This method checks if the simulation about to be run has already been saved in the \"simulations\" folder, by checking the .json parameter files. Returns: Type Description (tuple) tuple containing: - bool : True if simulation already exists, False otherwise. - str : Name of the file if the simulation has already been run. Source code in nanotrappy\\trapping\\simulation.py def exists_in_past_simulations ( self ): \"\"\"This method checks if the simulation about to be run has already been saved in the \"simulations\" folder, by checking the .json parameter files. Returns: (tuple): tuple containing: - bool : True if simulation already exists, False otherwise. - str : Name of the file if the simulation has already been run. \"\"\" self . set_current_params () try : os . listdir ( self . data_folder + \"/simulations\" ) except FileNotFoundError : os . mkdir ( self . data_folder + \"/simulations\" ) for file in os . listdir ( self . data_folder + \"/simulations\" ): if file . endswith ( \".json\" ): with open ( self . data_folder + \"/simulations/\" + file ) as json_file : params = json . load ( json_file ) # initializing compare keys comp_keys = [ \"Atomic system\" , \"Material\" , \"Trap wavelengths\" , \"Considered state\" , \"Geometry\" , \"Surface\" ] # Compare Dictionaries on certain keys using all() res = all ( params . get ( key ) == self . params . get ( key ) for key in comp_keys ) if res : self . data_file = file [: - 4 ] + \"npy\" self . E_file = file [: - 5 ] + \"E_field.npy\" self . vecs_file = file [: - 5 ] + \"vecs.npy\" return True return False","title":"exists_in_past_simulations()"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.Simulation.save","text":"Saves both the parameters dictionnary into a .json file and the potentials attribute into a .npy. Source code in nanotrappy\\trapping\\simulation.py def save ( self ): \"\"\"Saves both the parameters dictionnary into a .json file and the potentials attribute into a .npy.\"\"\" if not self . already_saved : current_time = self . params [ \"Time of simulation\" ] current_time = current_time . replace ( \"/\" , \"_\" ) current_time = current_time . replace ( \":\" , \"_\" ) current_time = current_time . replace ( \" \" , \"_\" ) filename_params = self . data_folder + \"/simulations/\" + str ( current_time ) + \".json\" filename_data = self . data_folder + \"/simulations/\" + str ( current_time ) + \".npy\" E_filename_data = self . data_folder + \"/simulations/\" + str ( current_time ) + \"E_field.npy\" vecs_filename_data = self . data_folder + \"/simulations/\" + str ( current_time ) + \"vecs.npy\" if not os . path . exists ( os . path . dirname ( filename_params )): try : os . makedirs ( os . path . dirname ( filename_params )) except OSError as exc : # Guard against race condition if exc . errno != errno . EEXIST : raise with open ( filename_params , \"w\" ) as fp : json . dump ( self . params , fp ) np . save ( filename_data , self . potentials ) np . save ( E_filename_data , self . Etot ) np . save ( vecs_filename_data , self . vecs ) self . already_saved = True else : print ( \"This simulation has already been saved, see %s \" % ( self . data_file ))","title":"save()"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.Simulation.set_current_params","text":"Sets a dictionnary with all the relevant parameters of the Simulation object and returns it. Returns: Type Description dict parameters of the simulation Source code in nanotrappy\\trapping\\simulation.py def set_current_params ( self ): \"\"\"Sets a dictionnary with all the relevant parameters of the Simulation object and returns it. Returns: dict : parameters of the simulation \"\"\" self . lmbdas_params = np . array ([]) self . P_params = np . array ([]) for ( k , beam ) in enumerate ( self . trap . beams ): self . lmbdas_params = np . append ( self . lmbdas_params , beam . get_lmbda ()) self . P_params = np . append ( self . P_params , beam . get_power ()) self . lmbdas_params . resize ( 2 * ( k + 1 ), refcheck = False ) self . P_params . resize ( 2 * ( k + 1 ), refcheck = False ) self . lmbdas_params . resize ( 4 , refcheck = False ) self . P_params . resize ( 4 , refcheck = False ) lambda1pair1 = str ( self . lmbdas_params [ 0 ] / nm ) + \" nm\" power1pair1 = str ( self . P_params [ 0 ] / mW ) + \" mW\" lambda2pair1 = str ( self . lmbdas_params [ 1 ] / nm ) + \" nm\" power2pair1 = str ( self . P_params [ 1 ] / mW ) + \" mW\" lambda1pair2 = str ( self . lmbdas_params [ 2 ] / nm ) + \" nm\" power1pair2 = str ( self . P_params [ 2 ] / mW ) + \" mW\" lambda2pair2 = str ( self . lmbdas_params [ 3 ] / nm ) + \" nm\" power2pair2 = str ( self . P_params [ 3 ] / mW ) + \" mW\" now = datetime . now () current_time = now . strftime ( \" %d /%m/%Y %H:%M:%S\" ) self . params = { \"Time of simulation\" : current_time , \"Atomic system\" : { \"species\" : type ( self . atomicsystem . atom ) . __name__ , \"groundstate\" : str ( self . atomicsystem . groundstate ), \"hyperfine level\" : int ( self . atomicsystem . f ), }, \"Material\" : str ( self . material ), \"Trap wavelengths\" : { \"lambda 1 pair 1\" : lambda1pair1 , \"lambda 2 pair 1\" : lambda2pair1 , \"lambda 1 pair 2\" : lambda1pair2 , \"lambda 2 pair 2\" : lambda2pair2 , }, \"Trap powers\" : { \"power 1 pair 1\" : power1pair1 , \"power 2 pair 1\" : power2pair1 , \"power 1 pair 2\" : power1pair2 , \"power 2 pair 2\" : power2pair2 , }, \"Considered state\" : str ( self . atomicsystem . state ), \"Geometry\" : { \"2D\" : self . geometry . dimension == 2 , \"2D plane\" : self . geometry . name if self . geometry . isPlane () else None , \"2D orthogonal coord\" : self . geometry . normal_coord if self . geometry . isPlane () else None , \"1D\" : self . geometry . dimension == 1 , \"1D axis\" : self . geometry . name if self . geometry . isAxis () else None , \"1D coord1\" : self . geometry . coordinates [ 0 ] if self . geometry . isAxis () else None , \"1D coord2\" : self . geometry . coordinates [ 1 ] if self . geometry . isAxis () else None , }, \"Surface\" : [ surface . params for surface in self . surface ], \"Data_folder\" : self . data_folder , } print ( \"[INFO] Simulation parameters set\" ) return self . params","title":"set_current_params()"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.Simulation.set_wavelengths_indices","text":"Compares the wavelengths of the beams specified for the trap with the wavelengths of the available modes in the data folder and returns the list of the file indices that correspond. The wavelengths are rounded to 0.01 nm before comparison. !!! note Passed as property so it is updated anytime the trap is changed !!! raises ValueError: If at least one wavelength wanted for the trap cannot be found in the data folder. Source code in nanotrappy\\trapping\\simulation.py def set_wavelengths_indices ( self ): \"\"\"Compares the wavelengths of the beams specified for the trap with the wavelengths of the available modes in the data folder and returns the list of the file indices that correspond. The wavelengths are rounded to 0.01 nm before comparison. Note: Passed as property so it is updated anytime the trap is changed Raises: ValueError: If at least one wavelength wanted for the trap cannot be found in the data folder. \"\"\" self . wavelengths_indices = np . array ([], dtype = int ) for elem in self . trap . lmbdas : idx = np . where ( np . isclose ( self . lmbdas_modes , elem , atol = 1e-11 )) if len ( idx [ 0 ]) != 0 : self . wavelengths_indices = np . append ( self . wavelengths_indices , idx ) else : raise ValueError ( \"Demanded wavelengths for trap not found in data folder, the possible wavelengths are the following: \" , np . sort ( self . lmbdas_modes ), )","title":"set_wavelengths_indices()"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.Simulation.total_potential","text":"Uses the potentials attributes of the Simulation object for each beam to return their weighted sum with the specified powers Returns: Type Description total potential array with shape(length coordinate 1,length coordinate 2,number of possbile mf states) Source code in nanotrappy\\trapping\\simulation.py def total_potential ( self ): \"\"\"Uses the potentials attributes of the Simulation object for each beam to return their weighted sum with the specified powers Returns: total potential : array with shape(length coordinate 1,length coordinate 2,number of possbile mf states) \"\"\" self . total_potential_noCP = np . zeros ( np . shape ( self . potentials [ 0 ]), dtype = \"float\" ) self . total_vecs = np . zeros ( np . shape ( self . vecs [ 0 ]), dtype = \"complex\" ) for ( i , potential ) in enumerate ( self . potentials ): self . total_potential_noCP = self . total_potential_noCP + self . trap . beams [ i ] . get_power () * potential self . total_vecs = self . trap . beams [ i ] . get_power () * self . vecs [ i ] norm_total_vecs = np . linalg . norm ( self . total_vecs , axis =- 1 ) number_mf_levels = self . total_vecs . shape [ - 1 ] for m in range ( number_mf_levels ): self . total_vecs [ ... , m ] /= norm_total_vecs return self . total_potential_noCP + np . dstack ([ self . CP ] * number_mf_levels )","title":"total_potential()"},{"location":"reference/simulation/#nanotrappy.trapping.simulation.parse_lmbdas","text":"This function opens all the .npy file of the given data_folder and stores the wavelengths of the modes in an array. Parameters: Name Type Description Default data_folder str Absolute path of the folder containing the computed available modes. required Returns: Type Description array np array with all the available wavelengths. Source code in nanotrappy\\trapping\\simulation.py def parse_lmbdas ( data_folder ): \"\"\"This function opens all the .npy file of the given data_folder and stores the wavelengths of the modes in an array. Args: data_folder (str): Absolute path of the folder containing the computed available modes. Returns: array : np array with all the available wavelengths. \"\"\" lmbdas_modes = np . array ([]) files = np . array ([ f for f in os . listdir ( data_folder ) if f . endswith ( \".npy\" )]) for filename in files : l = np . load ( data_folder + \"//\" + filename , allow_pickle = True )[ 0 ] lmbdas_modes = np . append ( lmbdas_modes , l ) return lmbdas_modes","title":"parse_lmbdas()"},{"location":"reference/trap/","text":"\u00b6 Trap_beams \u00b6 A class to represent a trap, wich is a bundle of beams and a propagation axis. Attributes: Name Type Description beams An array of Beams instances. propagation_axis str A string that represents the propagation axis of the trap. Exceptions: Type Description ValueError if no beam is provided ValueError if 3 Beams are provided, please put two of them in a Pair. Todo Add a way to put as many beams as wanted in a trap. Examples: To create a trap, first create the instances of Beams: >>> BP = BeamPair ( 935e-9 , \"f\" , 1 * mW , 935e-9 , \"f\" , 1 * mW ) >>> B = Beam ( 685e-9 , \"f\" , 1 * mW ) >>> trap = Trap ( BP , B , propagation_axis = \"X\" ) directions property readonly \u00b6 Get the directions of each beam in the trap Returns: Type Description array directions of each beam in the trap lmbdas property readonly \u00b6 Get the wavelengths of each beam in the trap Returns: Type Description array wavelengths of each beam in the trap (m) powers property readonly \u00b6 Get the powers of each beam in the trap Returns: Type Description array powers of each beam in the trap (W) set_powers ( self , powerlist ) \u00b6 Set the powers of each beam in the trap Parameters: Name Type Description Default powerlist list list of one power per Beam (W) required Exceptions: Type Description ValueError too many powers provided Caution Only provide one power for a BeamPair. Source code in nanotrappy\\trapping\\trap.py def set_powers ( self , powerlist ): \"\"\"Set the powers of each beam in the trap Args: powerlist (list): list of one power per Beam (W) Raises: ValueError: too many powers provided Caution: Only provide one power for a BeamPair. \"\"\" if len ( powerlist ) == len ( self . beams ): for beam in self . beams : beam . set_power ( powerlist . pop ( 0 )) else : raise ValueError ( \"You must give as many powers as there are beams\" )","title":"Trap"},{"location":"reference/trap/#nanotrappy.trapping.trap","text":"","title":"nanotrappy.trapping.trap"},{"location":"reference/trap/#nanotrappy.trapping.trap.Trap_beams","text":"A class to represent a trap, wich is a bundle of beams and a propagation axis. Attributes: Name Type Description beams An array of Beams instances. propagation_axis str A string that represents the propagation axis of the trap. Exceptions: Type Description ValueError if no beam is provided ValueError if 3 Beams are provided, please put two of them in a Pair. Todo Add a way to put as many beams as wanted in a trap. Examples: To create a trap, first create the instances of Beams: >>> BP = BeamPair ( 935e-9 , \"f\" , 1 * mW , 935e-9 , \"f\" , 1 * mW ) >>> B = Beam ( 685e-9 , \"f\" , 1 * mW ) >>> trap = Trap ( BP , B , propagation_axis = \"X\" )","title":"Trap_beams"},{"location":"reference/trap/#nanotrappy.trapping.trap.Trap_beams.directions","text":"Get the directions of each beam in the trap Returns: Type Description array directions of each beam in the trap","title":"directions"},{"location":"reference/trap/#nanotrappy.trapping.trap.Trap_beams.lmbdas","text":"Get the wavelengths of each beam in the trap Returns: Type Description array wavelengths of each beam in the trap (m)","title":"lmbdas"},{"location":"reference/trap/#nanotrappy.trapping.trap.Trap_beams.powers","text":"Get the powers of each beam in the trap Returns: Type Description array powers of each beam in the trap (W)","title":"powers"},{"location":"reference/trap/#nanotrappy.trapping.trap.Trap_beams.set_powers","text":"Set the powers of each beam in the trap Parameters: Name Type Description Default powerlist list list of one power per Beam (W) required Exceptions: Type Description ValueError too many powers provided Caution Only provide one power for a BeamPair. Source code in nanotrappy\\trapping\\trap.py def set_powers ( self , powerlist ): \"\"\"Set the powers of each beam in the trap Args: powerlist (list): list of one power per Beam (W) Raises: ValueError: too many powers provided Caution: Only provide one power for a BeamPair. \"\"\" if len ( powerlist ) == len ( self . beams ): for beam in self . beams : beam . set_power ( powerlist . pop ( 0 )) else : raise ValueError ( \"You must give as many powers as there are beams\" )","title":"set_powers()"},{"location":"reference/viz/","text":"\u00b6 DiscreteSlider \u00b6 A matplotlib slider widget with discrete steps. set_val ( self , val ) \u00b6 Set slider value to val Parameters \u00b6 val : float Source code in nanotrappy\\utils\\viz.py def set_val ( self , val ): discrete_val = self . allowed_vals [ abs ( val - self . allowed_vals ) . argmin ()] val = discrete_val xy = self . poly . xy if self . orientation == \"vertical\" : xy [ 1 ] = 0 , val xy [ 2 ] = 1 , val else : xy [ 2 ] = val , 1 xy [ 3 ] = val , 0 self . poly . xy = xy self . valtext . set_text ( self . valfmt % val ) if self . drawon : self . ax . figure . canvas . draw_idle () self . val = val if not self . eventson : return for cid , func in self . observers . items (): func ( val ) Viz \u00b6 Class that contains all the visualization methods. Attributes: Name Type Description simul Simulation object Simulation object contaning a trap, a system and a surface. For most of the methods in the class, the simulations have to be run beforehand. trapping_axis str Axis perpendicular to the structure along which we want to trap the atoms. Important for the 3 1D plot method. Either \"X\", \"Y\" or \"Z\". get_coord_trap_outside_structure ( self , axis , coord1 , coord2 , mf = 0 , edge_no_surface = None ) \u00b6 Returns the truncation of both the specified axis and the trap along that direction, setting 0 for the coordinate at the edge of the structure. Parameters: Name Type Description Default axis str axis along which we are looking at the trap. required coord1 float First coordinate on the orthogonal plane to the required coord2 float Second coordinate on the orthogonal plane to the required mf int or list Mixed mf state we want to analyze. Default to 0. 0 edge_no_surface float Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. None Exceptions: Type Description TypeError if only a 2D computation of the potential has been done before plotting. Returns: Type Description (tuple) - int: Index of the specified mf state in the array - float: Position of the edge of the structure (taken either from the Surface object or given by the user). - array: New coordinates, with 0 at the edge of the structure and negative values truncated. - array: Corresponding truncation of the trapping potential. Source code in nanotrappy\\utils\\viz.py def get_coord_trap_outside_structure ( self , axis , coord1 , coord2 , mf = 0 , edge_no_surface = None ): \"\"\"Returns the truncation of both the specified axis and the trap along that direction, setting 0 for the coordinate at the edge of the structure. Args: axis (str): axis along which we are looking at the trap. coord1 (float): First coordinate on the orthogonal plane to the trapping axis. If axis is Y, coord1 should be the one on X. coord2 (float): Second coordinate on the orthogonal plane to the trapping axis. mf (int or list): Mixed mf state we want to analyze. Default to 0. edge_no_surface (float): Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. Raise: TypeError: if only a 2D computation of the potential has been done before plotting. Returns: (tuple): containing: - int: Index of the specified mf state in the array - float: Position of the edge of the structure (taken either from the Surface object or given by the user). - array: New coordinates, with 0 at the edge of the structure and negative values truncated. - array: Corresponding truncation of the trapping potential. \"\"\" _ , mf = check_mf ( self . simul . atomicsystem . f , mf ) mf_index = int ( mf + self . simul . atomicsystem . f ) coord = set_axis_from_axis ( axis , self . simul ) trap = np . real ( self . simul . compute_potential_1D ( axis , coord1 , coord2 ))[:, mf_index ] if axis != self . trapping_axis : index_edge = 0 edge = 0 y_outside = coord trap_outside = trap elif axis == self . trapping_axis and type ( self . simul . surface ) . __name__ == \"NoSurface\" : if edge_no_surface is None : raise ValueError ( \"No surface for CP interactions have been specified. To restrict the search for the minimum in the right zone, you have to specify an edge\" ) edge = edge_no_surface index_edge = np . argmin ( np . abs ( coord - edge )) y_outside = coord [ index_edge :] - edge trap_outside = trap [ index_edge :] else : peaks = find_peaks ( - self . simul . CP [:, mf_index ], height = 10 ) if len ( peaks [ 0 ]) == 0 : index_edge = 0 edge = 0 y_outside = coord trap_outside = trap elif len ( peaks [ 0 ]) == 1 : index_edge = peaks [ 0 ][ 0 ] edge = coord [ index_edge - 1 ] y_outside = coord [ index_edge :] - edge trap_outside = trap [ index_edge :] elif len ( peaks [ 0 ]) == 2 and type ( self . simul . surface [ 0 ]) . __name__ == \"Cylinder\" : index_edge = peaks [ 0 ][ - 1 ] edge = coord [ index_edge + 1 ] y_outside = coord [ index_edge :] - edge trap_outside = trap [ index_edge :] elif len ( peaks [ 0 ]) == 2 : index_edge = peaks [ 0 ] edge = coord [ index_edge [ 0 ] - 1 ] y_outside = coord [ index_edge [ 0 ] : index_edge [ 1 ]] - edge trap_outside = trap [ index_edge [ 0 ] : index_edge [ 1 ]] else : raise ValueError ( \"Too many structures set\" ) return mf_index , edge , y_outside , trap_outside get_min_trap ( self , y_outside , trap_outside , edge_no_surface = None ) \u00b6 Finds the minimum of the trap (ie total_potential()) computed in the simulation object Parameters: Name Type Description Default y_outside array truncated coordinates required trap_outside array truncated 1D trap required axis str axis along which we are looking at the trap. required mf int or list Mixed mf state we want to analyze. Default to 0. required edge_no_surface float Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. None Exceptions: Type Description TypeError if only a 2D computation of the potential has been done before plotting. Returns: Type Description (tuple) - int: Index of the position of the minimum (from the outside coordinate, putting the surface at 0). - float: Position of the trap minimum when putting the surface at 0. - float: Trap depth (ie, value of the trap at the minimum). - float: Height of the potential barrier for the atoms (ie difference between the trap depth and the closest local maxima). - float: Idx of left prominence if exists Source code in nanotrappy\\utils\\viz.py def get_min_trap ( self , y_outside , trap_outside , edge_no_surface = None ): \"\"\"Finds the minimum of the trap (ie total_potential()) computed in the simulation object Args: y_outside (array): truncated coordinates trap_outside (array): truncated 1D trap axis (str): axis along which we are looking at the trap. mf (int or list): Mixed mf state we want to analyze. Default to 0. edge_no_surface (float): Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. Raise: TypeError: if only a 2D computation of the potential has been done before plotting. Returns: (tuple): containing: - int: Index of the position of the minimum (from the outside coordinate, putting the surface at 0). - float: Position of the trap minimum when putting the surface at 0. - float: Trap depth (ie, value of the trap at the minimum). - float: Height of the potential barrier for the atoms (ie difference between the trap depth and the closest local maxima). - float: Idx of left prominence if exists \"\"\" if np . ndim ( trap_outside ) >= 3 : raise TypeError ( \"This method can only be used if a 1D computation of the potential has been done.\" ) local_minima = find_peaks ( - trap_outside , distance = 10 , prominence = 5e-4 ) if len ( local_minima [ 0 ]) == 0 : print ( \"[WARNING] No local minimum found\" ) return np . nan , np . nan , 0 , 0 , np . nan elif len ( local_minima [ 0 ]) == 1 and local_minima [ 0 ][ 0 ] > 5 : print ( \"[INFO] One local miminum found at %s \" % ( y_outside [ local_minima [ 0 ][ 0 ]])) return ( local_minima [ 0 ][ 0 ], y_outside [ local_minima [ 0 ][ 0 ]], trap_outside [ local_minima [ 0 ][ 0 ]], - local_minima [ 1 ][ \"prominences\" ][ 0 ], local_minima [ 1 ][ \"left_bases\" ][ 0 ], ) elif len ( local_minima [ 0 ]) == 1 and local_minima [ 0 ][ 0 ] <= 5 : print ( \"[WARNING] One local minimum found but too close to the edge of the structure\" ) return np . nan , np . nan , 0 , 0 , np . nan else : arg = np . argmin ( np . real ( trap_outside [ local_minima [ 0 ]])) print ( \"[WARNING] Many local minima found, taking only the lowest one into account at %s \" % ( y_outside [ local_minima [ 0 ][ arg ]]) ) return ( local_minima [ 0 ][ arg ], y_outside [ local_minima [ 0 ][ arg ]], trap_outside [ local_minima [ 0 ][ arg ]], - local_minima [ 1 ][ \"prominences\" ][ arg ], local_minima [ 1 ][ \"left_bases\" ][ 0 ], ) get_trapfreq ( self , y_outside , trap_outside , edge_no_surface = None ) \u00b6 Finds the value of the trapping frequency (in Hz) along the specified axis Parameters: Name Type Description Default simul Simulation object A simulation object with computation of 1D potential already run. required axis str axis along which we want to compute the trapping frequency. required mf int or list Mixed mf state we want to analyze. Default to 0. required edge_no_surface float Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. None Exceptions: Type Description TypeError if only a 2D computation of the potential has been done before plotting. Returns: Type Description float Trapping frequency along the axis (in Hz) Source code in nanotrappy\\utils\\viz.py def get_trapfreq ( self , y_outside , trap_outside , edge_no_surface = None ): \"\"\"Finds the value of the trapping frequency (in Hz) along the specified axis Args: simul (Simulation object): A simulation object with computation of 1D potential already run. axis (str): axis along which we want to compute the trapping frequency. mf (int or list): Mixed mf state we want to analyze. Default to 0. edge_no_surface (float): Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. Raise: TypeError: if only a 2D computation of the potential has been done before plotting. Returns: float: Trapping frequency along the axis (in Hz) \"\"\" if np . ndim ( trap_outside ) >= 3 : raise TypeError ( \"The trap given must be one-dimensional\" ) min_pos_index , min_pos , depth , height , height_idx = self . get_min_trap ( y_outside , trap_outside , edge_no_surface ) if np . isnan ( min_pos ): trap_outside3 = np . concatenate (( trap_outside , trap_outside , trap_outside )) y_outside3 = np . concatenate ( ( y_outside - ( y_outside [ - 1 ] - y_outside [ 0 ]), y_outside , y_outside + ( y_outside [ - 1 ] - y_outside [ 0 ])) ) min_pos_index , min_pos , depth , height , height_idx = self . get_min_trap ( y_outside3 , trap_outside3 , edge_no_surface ) if np . isnan ( min_pos ): print ( \"[WARNING] No local minimum along the axis. Cannot compute trapping frequency.\" ) return 0 else : pass height_pos = y_outside [ height_idx ] ## Gives the position of the barrier yleft = min_pos - ( min_pos - height_pos ) / 2 yright = min_pos + ( min_pos - height_pos ) / 2 idx_left = find_nearest ( y_outside , yleft ) idx_right = find_nearest ( y_outside , yright ) fit = np . polyfit ( y_outside [ idx_left : idx_right ], trap_outside [ idx_left : idx_right ], 2 ) p = np . poly1d ( fit ) der_fit = np . real ( np . gradient ( p ( y_outside ), y_outside )) der2_fit = np . gradient ( der_fit , y_outside ) index_min = np . argmin ( np . abs ( y_outside - min_pos )) moment2 = der2_fit [ index_min ] trap_freq = np . sqrt (( moment2 * kB * mK ) / ( self . simul . atomicsystem . mass )) * ( 1 / ( 2 * np . pi )) return trap_freq plot_3axis ( self , coord1 , coord2 , mf = 0 , Pranges = [ 10 , 10 ], increments = [ 0.1 , 0.1 ]) \u00b6 Shows 3 1D plots of the total potential with power sliders, and trapping frequencies for each axis if possible. Starts by simulating a 1D trap along the trapping_axis attribute of the Viz object and finds the minimum. Once found, simulates 1D traps in the 2 other orthogonal directions and finds the associated frequency. When looking at nanostructure with possible different trapping axis (like nanofibers), a new Viz object has to be defined in order to use this method. Parameters: Name Type Description Default coord1 float First coordinate on the orthogonal plane to the trapping axis. If trapping axis is Y, coord1 should be the one on X. required coord2 float Second coordinate on the orthogonal plane to the trapping axis. required mf int integer between -F and +F. No list possible here. 0 Pranges list List with the maximum values of the beam powers we want to display on the sliders. Defaults to [10,10] [10, 10] Returns: Type Description (tuple) - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) Source code in nanotrappy\\utils\\viz.py def plot_3axis ( self , coord1 , coord2 , mf = 0 , Pranges = [ 10 , 10 ], increments = [ 0.1 , 0.1 ]): \"\"\"Shows 3 1D plots of the total potential with power sliders, and trapping frequencies for each axis if possible. Starts by simulating a 1D trap along the trapping_axis attribute of the Viz object and finds the minimum. Once found, simulates 1D traps in the 2 other orthogonal directions and finds the associated frequency. When looking at nanostructure with possible different trapping axis (like nanofibers), a new Viz object has to be defined in order to use this method. Args: coord1 (float): First coordinate on the orthogonal plane to the trapping axis. If trapping axis is Y, coord1 should be the one on X. coord2 (float): Second coordinate on the orthogonal plane to the trapping axis. mf (int): integer between -F and +F. No list possible here. Pranges (list): List with the maximum values of the beam powers we want to display on the sliders. Defaults to [10,10] Returns: (tuple): containing: - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) \"\"\" _ , mf = check_mf ( self . simul . atomicsystem . f , mf ) if len ( mf ) > 1 : raise ValueError ( \"This 3D plot can only be done for one specific mf at a time\" ) mf_shift = mf + self . simul . atomicsystem . f axis_of_interest , axis1 , axis2 = get_sorted_axis ( self . trapping_axis , self . simul ) axis1_name , axis2_name = get_sorted_axis_name ( self . trapping_axis ) axis_index , axis1_index , axis2_index = set_axis_index_from_axis ( self . trapping_axis ) axis_name_list = [ self . trapping_axis , axis1_name , axis2_name ] if len ( self . simul . E [ 0 ] . shape ) != 4 : print ( \"[WARNING] 3D Electric fields must be fed in the Simulation class in order to use this function\" ) else : mf_index , edge , y_outside , trap_1D_Y_outside = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) ymin_ind , y_min , trap_depth , trap_prominence , _ = self . get_min_trap ( y_outside , trap_1D_Y_outside ) omegax , omegay , omegaz = 0 , 0 , 0 if not np . isnan ( y_min ): min_pos = np . zeros ( 3 ) min_pos [ axis_index ] = y_min + edge min_pos [ axis1_index ] = coord1 min_pos [ axis2_index ] = coord2 _ , _ , y_outside , trap_1D_Y_outside = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) omegay = self . get_trapfreq ( y_outside , trap_1D_Y_outside ) _ , _ , x_outside , trap_1D_X_allw = self . get_coord_trap_outside_structure ( axis1_name , np . delete ( min_pos , axis1_index )[ 0 ], np . delete ( min_pos , axis1_index )[ 1 ], mf , edge_no_surface = None , ) omegax = self . get_trapfreq ( x_outside , trap_1D_X_allw ) _ , _ , z_outside , trap_1D_Z_allw = self . get_coord_trap_outside_structure ( axis2_name , np . delete ( min_pos , axis2_index )[ 0 ], np . delete ( min_pos , axis2_index )[ 1 ], mf , edge_no_surface = None , ) omegaz = self . get_trapfreq ( z_outside , trap_1D_Z_allw ) fig , ax = plt . subplots ( 3 , figsize = ( 15 , 10 )) plt . subplots_adjust ( left = 0.25 ) axcolor = \"lightgoldenrodyellow\" props = dict ( boxstyle = \"round\" , facecolor = axcolor , alpha = 0.5 ) textstr = \" \\n \" . join ( ( r \"$\\mathrm{trap \\, position}= %.2f (nm) $\" % ( y_min * 1e9 ,), r \"$\\mathrm {depth} = %.2f (mK) $\" % ( trap_depth ,), r \"$\\omega_ %s = %.2f (kHz) $\" % ( self . trapping_axis , omegay * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis1_name , omegax * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis2_name , omegaz * 1e-3 , ), ) ) box = plt . text ( - 0.3 , 0.6 , textstr , transform = ax [ 2 ] . transAxes , fontsize = 14 , verticalalignment = \"top\" , bbox = props ) slider_ax = [] axes = [] for ( k , beam ) in enumerate ( self . simul . trap . beams ): axes . append ( plt . axes ([ 0.1 + k * 0.05 , 0.32 , 0.03 , 0.5 ], facecolor = axcolor )) print ( self . simul . trap . beams [ k ] . get_power ()) slider_ax . append ( Slider ( axes [ k ], \"Power \\n Beam %s \\n (mW)\" % ( k + 1 ), 0 , Pranges [ k ], valinit = self . simul . trap . beams [ k ] . get_power () * 1e3 , valstep = increments [ k ], orientation = \"vertical\" , ) ) index_1 = np . argmin ( np . abs ( axis1 - coord1 )) index_2 = np . argmin ( np . abs ( axis2 - coord2 )) ( ly ,) = ax [ 0 ] . plot ( y_outside , trap_1D_Y_outside , linewidth = 3 , color = \"darkblue\" ) ax [ 0 ] . set_ylim ([ - 2 , 2 ]) if not np . isnan ( y_min ): ( point ,) = ax [ 0 ] . plot ( y_outside [ int ( ymin_ind )], trap_1D_Y_outside [ int ( ymin_ind )], \"ro\" ) ( lx ,) = ax [ 1 ] . plot ( axis1 , trap_1D_X_allw , linewidth = 2 , color = \"royalblue\" ) ( lz ,) = ax [ 2 ] . plot ( axis2 , trap_1D_Z_allw , linewidth = 2 , color = \"royalblue\" ) ( point1 ,) = ax [ 1 ] . plot ( axis1 [ index_1 ], trap_1D_X_allw [ index_1 ], \"ro\" ) ( point2 ,) = ax [ 2 ] . plot ( axis2 [ index_2 ], trap_1D_Z_allw [ index_2 ], \"ro\" ) else : ( lx ,) = ax [ 1 ] . plot ( axis1 , np . zeros (( len ( axis1 ),)), linewidth = 2 , color = \"royalblue\" ) ( lz ,) = ax [ 2 ] . plot ( axis2 , np . zeros (( len ( axis2 ),)), linewidth = 2 , color = \"royalblue\" ) plt . grid ( alpha = 0.5 ) for k in range ( len ( ax )): ax [ k ] . set_xlabel ( \" %s (m)\" % ( axis_name_list [ k ] . lower ()), fontsize = 14 ) plt . setp ( ax [ k ] . spines . values (), linewidth = 2 ) ax [ k ] . axhline ( y = 0 , color = \"black\" , linestyle = \"--\" , linewidth = 2 ) ax [ k ] . tick_params ( axis = \"both\" , which = \"major\" , labelsize = 14 ) ax [ 0 ] . set_title ( \"Total dipole trap for mf = %s in the 3 directions\" % ( mf [ 0 ]), fontsize = 18 ) fig . text ( 0.21 , 0.5 , \"Potential (mK)\" , ha = \"center\" , va = \"center\" , rotation = \"vertical\" , fontsize = 14 ) def updateP ( val ): P = [] for ( k , slider ) in enumerate ( slider_ax ): P . append ( slider . val * mW ) self . simul . trap . set_powers ( P ) mf_index , edge , y_outside , trap_1D_Y = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) ymin_ind , y_min , trap_depth , trap_prominence , _ = self . get_min_trap ( y_outside , trap_1D_Y ) print ( \"y_min = \" , y_min ) ax [ 0 ] . set_ylim ([ - 2 , trap_1D_Y . max ()]) axcolor = \"lightgoldenrodyellow\" props = dict ( boxstyle = \"round\" , facecolor = axcolor , alpha = 0.5 ) if not np . isnan ( y_min ): min_pos = np . zeros ( 3 ) min_pos [ axis_index ] = y_min + edge min_pos [ axis1_index ] = coord1 min_pos [ axis2_index ] = coord2 _ , _ , y_outside , trap_1D_Y = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) omegay = self . get_trapfreq ( y_outside , trap_1D_Y ) _ , _ , x_outside , trap_1D_X = self . get_coord_trap_outside_structure ( axis1_name , np . delete ( min_pos , axis1_index )[ 0 ], np . delete ( min_pos , axis1_index )[ 1 ], mf , edge_no_surface = None , ) omegax = self . get_trapfreq ( x_outside , trap_1D_X ) _ , _ , z_outside , trap_1D_Z = self . get_coord_trap_outside_structure ( axis2_name , np . delete ( min_pos , axis2_index )[ 0 ], np . delete ( min_pos , axis2_index )[ 1 ], mf , edge_no_surface = None , ) omegaz = self . get_trapfreq ( z_outside , trap_1D_Z ) lx . set_ydata ( trap_1D_X ) lz . set_ydata ( trap_1D_Z ) point . set_data ( y_outside [ ymin_ind ], trap_1D_Y [ ymin_ind ]) point1 . set_data ( axis1 [ index_1 ], trap_1D_X [ index_1 ]) point2 . set_data ( axis2 [ index_2 ], trap_1D_Z [ index_2 ]) ax [ 1 ] . set_ylim ([ trap_1D_X . min (), trap_1D_X . max ()]) ax [ 2 ] . set_ylim ([ trap_1D_Z . min (), trap_1D_Z . max ()]) ax [ 0 ] . set_ylim ([ 2 * trap_depth , 2 * trap_1D_Y . max ()]) textstr = \" \\n \" . join ( ( r \"$\\mathrm{trap \\, position}= %.2f (nm) $\" % ( y_min * 1e9 ,), r \"$\\mathrm {depth} = %.2f (mK) $\" % ( trap_depth ,), r \"$\\omega_ %s = %.2f (kHz) $\" % ( self . trapping_axis , omegay * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis1_name , omegax * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis2_name , omegaz * 1e-3 , ), ) ) box . set_text ( textstr ) else : textstr = r \"$\\mathrm {depth} = %.2f (mK) $\" % ( trap_depth ,) box . set_text ( textstr ) ly . set_ydata ( np . squeeze ( np . real ( trap_1D_Y ))) for slider in slider_ax : slider . on_changed ( updateP ) plt . show () return fig , ax , slider_ax plot_trap ( self , mf = 0 , Pranges = [ 10 , 10 ], increments = [ 0.1 , 0.1 ]) \u00b6 Shows a 2D plot of the total potential with power sliders Only available if a 2D simulation has been run. Parameters: Name Type Description Default plane str As we are dealing with 2D plots, we have to specify required mf int Mixed mf state we want to plot. In 2D we can only 0 Pranges list List with the maximum values of the beam powers [10, 10] Exceptions: Type Description TypeError if only a 1D computation of the potential has been Returns: Type Description (tuple) - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) Source code in nanotrappy\\utils\\viz.py def plot_trap ( self , mf = 0 , Pranges = [ 10 , 10 ], increments = [ 0.1 , 0.1 ]): \"\"\"Shows a 2D plot of the total potential with power sliders Only available if a 2D simulation has been run. Args: plane (str): As we are dealing with 2D plots, we have to specify the plane we are looking at to choose the right coordinates for plotting. mf (int): Mixed mf state we want to plot. In 2D we can only specify one integer. Default to 0. Pranges (list): List with the maximum values of the beam powers we want to display on the sliders. Defaults to [10,10] Raise: TypeError: if only a 1D computation of the potential has been done before plotting. Returns: (tuple): containing: - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) \"\"\" if np . ndim ( self . simul . total_potential ()) <= 2 : raise TypeError ( \"This method can only be used if a 2D computation of the potential has been done\" ) if len ( Pranges ) != len ( self . simul . trap . beams ): raise ValueError ( \"When specifying the upper ranges of P for plotting, you have to give as many as many values as there are beams.\" ) _ , mf = check_mf ( self . simul . atomicsystem . f , mf ) dimension = self . simul . geometry . get_dimension () # coord1, coord2 = set_axis_from_plane(plane, self.simul) if dimension == 2 : mf_index = int ( mf + self . simul . atomicsystem . f ) axis1 , axis2 = self . simul . geometry . get_base_axes () coord1 = axis1 . fetch_in ( self . simul ) coord2 = axis2 . fetch_in ( self . simul ) # coord1, coord2 = getattr(self.simul, axis1.name), getattr(self.simul, axis2.name) trap = np . real ( self . simul . total_potential ())[:, :, mf_index ] trap_noCP = np . real ( self . simul . total_potential_noCP [:, :, mf_index ]) fig , ax = plt . subplots () plt . subplots_adjust ( left = 0.5 , bottom = 0.1 ) # the norm TwoSlopeNorm allows to fix the 0 of potential to the white color, so that we can easily distinguish between positive and negative values of the potential a = ax . pcolormesh ( coord1 / nm , coord2 / nm , np . transpose ( trap ), shading = \"gouraud\" , norm = colors . TwoSlopeNorm ( vmin = min ( np . min ( trap_noCP ), - 0.001 ), vcenter = 0 , vmax = max ( np . max ( trap_noCP ) * 2 , 0.001 ) ), cmap = \"seismic_r\" , ) cbar = plt . colorbar ( a ) cbar . set_label ( \"Total potential (mK)\" , rotation = 270 , labelpad = 12 , fontsize = 14 ) ax . set_xlabel ( \" %s (nm)\" % ( self . simul . geometry . name [ 0 ] . lower ()), fontsize = 14 ) ax . set_ylabel ( \" %s (nm)\" % ( self . simul . geometry . name [ 1 ] . lower ()), fontsize = 14 ) plt . setp ( ax . spines . values (), linewidth = 1.5 ) ax . tick_params ( axis = \"both\" , which = \"major\" , labelsize = 14 ) ax . set_title ( \"2D plot of trapping potential \\n for mf = %s in the %s plane\" % ( mf , self . simul . geometry . name ), fontsize = 18 , ) ax . margins ( x = 0 ) axcolor = \"lightgoldenrodyellow\" slider_ax = [] axes = [] for ( k , beam ) in enumerate ( self . simul . trap . beams ): axes . append ( plt . axes ([ 0.15 + k * 0.08 , 0.1 , 0.03 , 0.75 ], facecolor = axcolor )) slider_ax . append ( Slider ( axes [ k ], \"Power \\n Beam %s (mW)\" % ( k + 1 ), 0 , Pranges [ k ], valinit = self . simul . trap . beams [ k ] . get_power () * 1e3 , valstep = increments [ k ], orientation = \"vertical\" , ) ) elif dimension == 1 : mf_index = mf + [ self . simul . atomicsystem . f ] # x = getattr(self.simul, self.simul.geometry.name) x = self . simul . geometry . fetch_in ( self . simul ) fig , ax = plt . subplots () plt . subplots_adjust ( bottom = 0.27 ) jet = cm = plt . get_cmap ( \"Greys\" ) cNorm = colors . Normalize ( vmin =- 1 , vmax = len ( mf )) scalarMap = cmx . ScalarMappable ( norm = cNorm , cmap = jet ) a = [] trap = np . real ( self . simul . total_potential ()[ 0 ]) trap_noCP = np . real ( self . simul . total_potential_noCP ) ax . set_xlabel ( \" %s (nm)\" % ( self . simul . geometry . name ), fontsize = 14 ) ax . set_ylabel ( \"E (mK)\" , fontsize = 14 ) plt . setp ( ax . spines . values (), linewidth = 1.5 ) ax . axhline ( y = 0 , color = \"black\" , linestyle = \"--\" , linewidth = 2 ) ax . tick_params ( axis = \"both\" , which = \"major\" , labelsize = 14 ) ax . set_title ( \"1D plot of trapping potential \\n for mf = %s along %s \" % ( mf , self . simul . geometry . name ), fontsize = 18 ) for k in range ( len ( mf_index )): colorVal = \"k\" # scalarMap.to_rgba(k) a = a + plt . plot ( x / nm , trap [:, mf_index [ k ]], color = colorVal , label = \"m$_f$ = %s \" % ( mf [ k ]), linewidth = 2 + 3 / len ( self . simul . mf_all ), ) if len ( mf ) == 1 and len ( self . simul . trap . beams ) == 2 : ( b ,) = plt . plot ( x / nm , np . real ( self . simul . trap . beams [ 0 ] . get_power () * np . real ( self . simul . potentials [ 0 , :, mf_index [ 0 ]])), color = \"blue\" , linewidth = 2 , ) ( r ,) = plt . plot ( x / nm , np . real ( self . simul . trap . beams [ 1 ] . get_power () * np . real ( self . simul . potentials [ 1 , :, mf_index [ 0 ]])), color = \"red\" , linewidth = 2 , ) else : pass # plt.legend() axcolor = \"lightgoldenrodyellow\" slider_ax = [] axes = [] for ( k , beam ) in enumerate ( self . simul . trap . beams ): axes . append ( plt . axes ([ 0.25 , 0.15 - k * 0.1 , 0.6 , 0.03 ], facecolor = axcolor )) slider_ax . append ( Slider ( axes [ k ], \"Power \\n Beam %s (mW)\" % ( k + 1 ), 0 , Pranges [ k ], valinit = self . simul . trap . beams [ k ] . get_power () * 1e3 , valstep = increments [ k ], ) ) slider_ax [ k ] . label . set_size ( 14 ) cursor = mplcursors . cursor ( a , highlight = True , highlight_kwargs = _custom_highlight_kwargs , annotation_kwargs = _custom_annotation_kwargs , ) @cursor . connect ( \"add\" ) def on_add ( sel ): artist = sel . artist label = artist . get_label () or \"\" mf = self . simul . atomicsystem . f + int ( label . split ()[ 2 ]) label = f \"Choice : { label } \" idx = int ( sel . target . index ) temp_vec = self . simul . total_vecs [ idx , mf ] temp_vec = np . abs ( temp_vec ) ** 2 decomp = f \"State : { vec_to_string ( temp_vec ) } \" x , y = sel . target textx = f \"x = { x : .1f } nm\" texty = f \"y = { y : .2f } mK\" size = max ( len ( textx ), len ( texty ), len ( decomp )) label = label . center ( size , \"-\" ) text = f \" { label } \\n { textx } \\n { texty } \\n { decomp } \" sel . annotation . set_text ( text ) def updateP ( val ): if dimension == 1 : for selection in cursor . selections : cursor . remove_selection ( selection ) P = [] for ( k , slider ) in enumerate ( slider_ax ): P . append ( slider . val * mW ) self . simul . trap . set_powers ( P ) trap = np . real ( self . simul . total_potential ()[ 0 ]) ### weird [0] for k in range ( len ( mf )): trap_k = trap [:, mf_index [ k ]] a [ k ] . set_ydata ( trap_k ) if len ( mf ) == 1 and len ( self . simul . trap . beams ) == 2 : b . set_ydata ( np . real ( self . simul . trap . beams [ 0 ] . get_power () * np . real ( self . simul . potentials [ 0 , :, mf_index [ 0 ]]) ) ) r . set_ydata ( np . real ( self . simul . trap . beams [ 1 ] . get_power () * np . real ( self . simul . potentials [ 1 , :, mf_index [ 0 ]]) ) ) elif dimension == 2 : P = [] for ( k , slider ) in enumerate ( slider_ax ): P . append ( slider . val * mW ) self . simul . trap . set_powers ( P ) trap_2D = self . simul . total_potential ()[:, :, mf_index ] a . set_array ( np . transpose ( np . real ( self . simul . total_potential_noCP [:, :, mf_index ])) . ravel ()) a . autoscale () a . set_array ( np . transpose ( np . real ( trap_2D )) . ravel ()) fig . canvas . draw_idle () for slider in slider_ax : slider . on_changed ( updateP ) # s1, s2 = np.transpose(trap).shape # LnTr = LineSlice(a, s1, s2, coord1 / nm, coord2 / nm, ax2) plt . show () return fig , ax , slider_ax","title":"Visualization"},{"location":"reference/viz/#nanotrappy.utils.viz","text":"","title":"nanotrappy.utils.viz"},{"location":"reference/viz/#nanotrappy.utils.viz.DiscreteSlider","text":"A matplotlib slider widget with discrete steps.","title":"DiscreteSlider"},{"location":"reference/viz/#nanotrappy.utils.viz.DiscreteSlider.set_val","text":"Set slider value to val","title":"set_val()"},{"location":"reference/viz/#parameters","text":"val : float Source code in nanotrappy\\utils\\viz.py def set_val ( self , val ): discrete_val = self . allowed_vals [ abs ( val - self . allowed_vals ) . argmin ()] val = discrete_val xy = self . poly . xy if self . orientation == \"vertical\" : xy [ 1 ] = 0 , val xy [ 2 ] = 1 , val else : xy [ 2 ] = val , 1 xy [ 3 ] = val , 0 self . poly . xy = xy self . valtext . set_text ( self . valfmt % val ) if self . drawon : self . ax . figure . canvas . draw_idle () self . val = val if not self . eventson : return for cid , func in self . observers . items (): func ( val )","title":"Parameters"},{"location":"reference/viz/#nanotrappy.utils.viz.Viz","text":"Class that contains all the visualization methods. Attributes: Name Type Description simul Simulation object Simulation object contaning a trap, a system and a surface. For most of the methods in the class, the simulations have to be run beforehand. trapping_axis str Axis perpendicular to the structure along which we want to trap the atoms. Important for the 3 1D plot method. Either \"X\", \"Y\" or \"Z\".","title":"Viz"},{"location":"reference/viz/#nanotrappy.utils.viz.Viz.get_coord_trap_outside_structure","text":"Returns the truncation of both the specified axis and the trap along that direction, setting 0 for the coordinate at the edge of the structure. Parameters: Name Type Description Default axis str axis along which we are looking at the trap. required coord1 float First coordinate on the orthogonal plane to the required coord2 float Second coordinate on the orthogonal plane to the required mf int or list Mixed mf state we want to analyze. Default to 0. 0 edge_no_surface float Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. None Exceptions: Type Description TypeError if only a 2D computation of the potential has been done before plotting. Returns: Type Description (tuple) - int: Index of the specified mf state in the array - float: Position of the edge of the structure (taken either from the Surface object or given by the user). - array: New coordinates, with 0 at the edge of the structure and negative values truncated. - array: Corresponding truncation of the trapping potential. Source code in nanotrappy\\utils\\viz.py def get_coord_trap_outside_structure ( self , axis , coord1 , coord2 , mf = 0 , edge_no_surface = None ): \"\"\"Returns the truncation of both the specified axis and the trap along that direction, setting 0 for the coordinate at the edge of the structure. Args: axis (str): axis along which we are looking at the trap. coord1 (float): First coordinate on the orthogonal plane to the trapping axis. If axis is Y, coord1 should be the one on X. coord2 (float): Second coordinate on the orthogonal plane to the trapping axis. mf (int or list): Mixed mf state we want to analyze. Default to 0. edge_no_surface (float): Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. Raise: TypeError: if only a 2D computation of the potential has been done before plotting. Returns: (tuple): containing: - int: Index of the specified mf state in the array - float: Position of the edge of the structure (taken either from the Surface object or given by the user). - array: New coordinates, with 0 at the edge of the structure and negative values truncated. - array: Corresponding truncation of the trapping potential. \"\"\" _ , mf = check_mf ( self . simul . atomicsystem . f , mf ) mf_index = int ( mf + self . simul . atomicsystem . f ) coord = set_axis_from_axis ( axis , self . simul ) trap = np . real ( self . simul . compute_potential_1D ( axis , coord1 , coord2 ))[:, mf_index ] if axis != self . trapping_axis : index_edge = 0 edge = 0 y_outside = coord trap_outside = trap elif axis == self . trapping_axis and type ( self . simul . surface ) . __name__ == \"NoSurface\" : if edge_no_surface is None : raise ValueError ( \"No surface for CP interactions have been specified. To restrict the search for the minimum in the right zone, you have to specify an edge\" ) edge = edge_no_surface index_edge = np . argmin ( np . abs ( coord - edge )) y_outside = coord [ index_edge :] - edge trap_outside = trap [ index_edge :] else : peaks = find_peaks ( - self . simul . CP [:, mf_index ], height = 10 ) if len ( peaks [ 0 ]) == 0 : index_edge = 0 edge = 0 y_outside = coord trap_outside = trap elif len ( peaks [ 0 ]) == 1 : index_edge = peaks [ 0 ][ 0 ] edge = coord [ index_edge - 1 ] y_outside = coord [ index_edge :] - edge trap_outside = trap [ index_edge :] elif len ( peaks [ 0 ]) == 2 and type ( self . simul . surface [ 0 ]) . __name__ == \"Cylinder\" : index_edge = peaks [ 0 ][ - 1 ] edge = coord [ index_edge + 1 ] y_outside = coord [ index_edge :] - edge trap_outside = trap [ index_edge :] elif len ( peaks [ 0 ]) == 2 : index_edge = peaks [ 0 ] edge = coord [ index_edge [ 0 ] - 1 ] y_outside = coord [ index_edge [ 0 ] : index_edge [ 1 ]] - edge trap_outside = trap [ index_edge [ 0 ] : index_edge [ 1 ]] else : raise ValueError ( \"Too many structures set\" ) return mf_index , edge , y_outside , trap_outside","title":"get_coord_trap_outside_structure()"},{"location":"reference/viz/#nanotrappy.utils.viz.Viz.get_min_trap","text":"Finds the minimum of the trap (ie total_potential()) computed in the simulation object Parameters: Name Type Description Default y_outside array truncated coordinates required trap_outside array truncated 1D trap required axis str axis along which we are looking at the trap. required mf int or list Mixed mf state we want to analyze. Default to 0. required edge_no_surface float Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. None Exceptions: Type Description TypeError if only a 2D computation of the potential has been done before plotting. Returns: Type Description (tuple) - int: Index of the position of the minimum (from the outside coordinate, putting the surface at 0). - float: Position of the trap minimum when putting the surface at 0. - float: Trap depth (ie, value of the trap at the minimum). - float: Height of the potential barrier for the atoms (ie difference between the trap depth and the closest local maxima). - float: Idx of left prominence if exists Source code in nanotrappy\\utils\\viz.py def get_min_trap ( self , y_outside , trap_outside , edge_no_surface = None ): \"\"\"Finds the minimum of the trap (ie total_potential()) computed in the simulation object Args: y_outside (array): truncated coordinates trap_outside (array): truncated 1D trap axis (str): axis along which we are looking at the trap. mf (int or list): Mixed mf state we want to analyze. Default to 0. edge_no_surface (float): Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. Raise: TypeError: if only a 2D computation of the potential has been done before plotting. Returns: (tuple): containing: - int: Index of the position of the minimum (from the outside coordinate, putting the surface at 0). - float: Position of the trap minimum when putting the surface at 0. - float: Trap depth (ie, value of the trap at the minimum). - float: Height of the potential barrier for the atoms (ie difference between the trap depth and the closest local maxima). - float: Idx of left prominence if exists \"\"\" if np . ndim ( trap_outside ) >= 3 : raise TypeError ( \"This method can only be used if a 1D computation of the potential has been done.\" ) local_minima = find_peaks ( - trap_outside , distance = 10 , prominence = 5e-4 ) if len ( local_minima [ 0 ]) == 0 : print ( \"[WARNING] No local minimum found\" ) return np . nan , np . nan , 0 , 0 , np . nan elif len ( local_minima [ 0 ]) == 1 and local_minima [ 0 ][ 0 ] > 5 : print ( \"[INFO] One local miminum found at %s \" % ( y_outside [ local_minima [ 0 ][ 0 ]])) return ( local_minima [ 0 ][ 0 ], y_outside [ local_minima [ 0 ][ 0 ]], trap_outside [ local_minima [ 0 ][ 0 ]], - local_minima [ 1 ][ \"prominences\" ][ 0 ], local_minima [ 1 ][ \"left_bases\" ][ 0 ], ) elif len ( local_minima [ 0 ]) == 1 and local_minima [ 0 ][ 0 ] <= 5 : print ( \"[WARNING] One local minimum found but too close to the edge of the structure\" ) return np . nan , np . nan , 0 , 0 , np . nan else : arg = np . argmin ( np . real ( trap_outside [ local_minima [ 0 ]])) print ( \"[WARNING] Many local minima found, taking only the lowest one into account at %s \" % ( y_outside [ local_minima [ 0 ][ arg ]]) ) return ( local_minima [ 0 ][ arg ], y_outside [ local_minima [ 0 ][ arg ]], trap_outside [ local_minima [ 0 ][ arg ]], - local_minima [ 1 ][ \"prominences\" ][ arg ], local_minima [ 1 ][ \"left_bases\" ][ 0 ], )","title":"get_min_trap()"},{"location":"reference/viz/#nanotrappy.utils.viz.Viz.get_trapfreq","text":"Finds the value of the trapping frequency (in Hz) along the specified axis Parameters: Name Type Description Default simul Simulation object A simulation object with computation of 1D potential already run. required axis str axis along which we want to compute the trapping frequency. required mf int or list Mixed mf state we want to analyze. Default to 0. required edge_no_surface float Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. None Exceptions: Type Description TypeError if only a 2D computation of the potential has been done before plotting. Returns: Type Description float Trapping frequency along the axis (in Hz) Source code in nanotrappy\\utils\\viz.py def get_trapfreq ( self , y_outside , trap_outside , edge_no_surface = None ): \"\"\"Finds the value of the trapping frequency (in Hz) along the specified axis Args: simul (Simulation object): A simulation object with computation of 1D potential already run. axis (str): axis along which we want to compute the trapping frequency. mf (int or list): Mixed mf state we want to analyze. Default to 0. edge_no_surface (float): Position of the edge of the structure. Only needed when no Surface is specified. When a Surface object is given, it is found automatically with the CP masks. Defaults to None. Raise: TypeError: if only a 2D computation of the potential has been done before plotting. Returns: float: Trapping frequency along the axis (in Hz) \"\"\" if np . ndim ( trap_outside ) >= 3 : raise TypeError ( \"The trap given must be one-dimensional\" ) min_pos_index , min_pos , depth , height , height_idx = self . get_min_trap ( y_outside , trap_outside , edge_no_surface ) if np . isnan ( min_pos ): trap_outside3 = np . concatenate (( trap_outside , trap_outside , trap_outside )) y_outside3 = np . concatenate ( ( y_outside - ( y_outside [ - 1 ] - y_outside [ 0 ]), y_outside , y_outside + ( y_outside [ - 1 ] - y_outside [ 0 ])) ) min_pos_index , min_pos , depth , height , height_idx = self . get_min_trap ( y_outside3 , trap_outside3 , edge_no_surface ) if np . isnan ( min_pos ): print ( \"[WARNING] No local minimum along the axis. Cannot compute trapping frequency.\" ) return 0 else : pass height_pos = y_outside [ height_idx ] ## Gives the position of the barrier yleft = min_pos - ( min_pos - height_pos ) / 2 yright = min_pos + ( min_pos - height_pos ) / 2 idx_left = find_nearest ( y_outside , yleft ) idx_right = find_nearest ( y_outside , yright ) fit = np . polyfit ( y_outside [ idx_left : idx_right ], trap_outside [ idx_left : idx_right ], 2 ) p = np . poly1d ( fit ) der_fit = np . real ( np . gradient ( p ( y_outside ), y_outside )) der2_fit = np . gradient ( der_fit , y_outside ) index_min = np . argmin ( np . abs ( y_outside - min_pos )) moment2 = der2_fit [ index_min ] trap_freq = np . sqrt (( moment2 * kB * mK ) / ( self . simul . atomicsystem . mass )) * ( 1 / ( 2 * np . pi )) return trap_freq","title":"get_trapfreq()"},{"location":"reference/viz/#nanotrappy.utils.viz.Viz.plot_3axis","text":"Shows 3 1D plots of the total potential with power sliders, and trapping frequencies for each axis if possible. Starts by simulating a 1D trap along the trapping_axis attribute of the Viz object and finds the minimum. Once found, simulates 1D traps in the 2 other orthogonal directions and finds the associated frequency. When looking at nanostructure with possible different trapping axis (like nanofibers), a new Viz object has to be defined in order to use this method. Parameters: Name Type Description Default coord1 float First coordinate on the orthogonal plane to the trapping axis. If trapping axis is Y, coord1 should be the one on X. required coord2 float Second coordinate on the orthogonal plane to the trapping axis. required mf int integer between -F and +F. No list possible here. 0 Pranges list List with the maximum values of the beam powers we want to display on the sliders. Defaults to [10,10] [10, 10] Returns: Type Description (tuple) - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) Source code in nanotrappy\\utils\\viz.py def plot_3axis ( self , coord1 , coord2 , mf = 0 , Pranges = [ 10 , 10 ], increments = [ 0.1 , 0.1 ]): \"\"\"Shows 3 1D plots of the total potential with power sliders, and trapping frequencies for each axis if possible. Starts by simulating a 1D trap along the trapping_axis attribute of the Viz object and finds the minimum. Once found, simulates 1D traps in the 2 other orthogonal directions and finds the associated frequency. When looking at nanostructure with possible different trapping axis (like nanofibers), a new Viz object has to be defined in order to use this method. Args: coord1 (float): First coordinate on the orthogonal plane to the trapping axis. If trapping axis is Y, coord1 should be the one on X. coord2 (float): Second coordinate on the orthogonal plane to the trapping axis. mf (int): integer between -F and +F. No list possible here. Pranges (list): List with the maximum values of the beam powers we want to display on the sliders. Defaults to [10,10] Returns: (tuple): containing: - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) \"\"\" _ , mf = check_mf ( self . simul . atomicsystem . f , mf ) if len ( mf ) > 1 : raise ValueError ( \"This 3D plot can only be done for one specific mf at a time\" ) mf_shift = mf + self . simul . atomicsystem . f axis_of_interest , axis1 , axis2 = get_sorted_axis ( self . trapping_axis , self . simul ) axis1_name , axis2_name = get_sorted_axis_name ( self . trapping_axis ) axis_index , axis1_index , axis2_index = set_axis_index_from_axis ( self . trapping_axis ) axis_name_list = [ self . trapping_axis , axis1_name , axis2_name ] if len ( self . simul . E [ 0 ] . shape ) != 4 : print ( \"[WARNING] 3D Electric fields must be fed in the Simulation class in order to use this function\" ) else : mf_index , edge , y_outside , trap_1D_Y_outside = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) ymin_ind , y_min , trap_depth , trap_prominence , _ = self . get_min_trap ( y_outside , trap_1D_Y_outside ) omegax , omegay , omegaz = 0 , 0 , 0 if not np . isnan ( y_min ): min_pos = np . zeros ( 3 ) min_pos [ axis_index ] = y_min + edge min_pos [ axis1_index ] = coord1 min_pos [ axis2_index ] = coord2 _ , _ , y_outside , trap_1D_Y_outside = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) omegay = self . get_trapfreq ( y_outside , trap_1D_Y_outside ) _ , _ , x_outside , trap_1D_X_allw = self . get_coord_trap_outside_structure ( axis1_name , np . delete ( min_pos , axis1_index )[ 0 ], np . delete ( min_pos , axis1_index )[ 1 ], mf , edge_no_surface = None , ) omegax = self . get_trapfreq ( x_outside , trap_1D_X_allw ) _ , _ , z_outside , trap_1D_Z_allw = self . get_coord_trap_outside_structure ( axis2_name , np . delete ( min_pos , axis2_index )[ 0 ], np . delete ( min_pos , axis2_index )[ 1 ], mf , edge_no_surface = None , ) omegaz = self . get_trapfreq ( z_outside , trap_1D_Z_allw ) fig , ax = plt . subplots ( 3 , figsize = ( 15 , 10 )) plt . subplots_adjust ( left = 0.25 ) axcolor = \"lightgoldenrodyellow\" props = dict ( boxstyle = \"round\" , facecolor = axcolor , alpha = 0.5 ) textstr = \" \\n \" . join ( ( r \"$\\mathrm{trap \\, position}= %.2f (nm) $\" % ( y_min * 1e9 ,), r \"$\\mathrm {depth} = %.2f (mK) $\" % ( trap_depth ,), r \"$\\omega_ %s = %.2f (kHz) $\" % ( self . trapping_axis , omegay * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis1_name , omegax * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis2_name , omegaz * 1e-3 , ), ) ) box = plt . text ( - 0.3 , 0.6 , textstr , transform = ax [ 2 ] . transAxes , fontsize = 14 , verticalalignment = \"top\" , bbox = props ) slider_ax = [] axes = [] for ( k , beam ) in enumerate ( self . simul . trap . beams ): axes . append ( plt . axes ([ 0.1 + k * 0.05 , 0.32 , 0.03 , 0.5 ], facecolor = axcolor )) print ( self . simul . trap . beams [ k ] . get_power ()) slider_ax . append ( Slider ( axes [ k ], \"Power \\n Beam %s \\n (mW)\" % ( k + 1 ), 0 , Pranges [ k ], valinit = self . simul . trap . beams [ k ] . get_power () * 1e3 , valstep = increments [ k ], orientation = \"vertical\" , ) ) index_1 = np . argmin ( np . abs ( axis1 - coord1 )) index_2 = np . argmin ( np . abs ( axis2 - coord2 )) ( ly ,) = ax [ 0 ] . plot ( y_outside , trap_1D_Y_outside , linewidth = 3 , color = \"darkblue\" ) ax [ 0 ] . set_ylim ([ - 2 , 2 ]) if not np . isnan ( y_min ): ( point ,) = ax [ 0 ] . plot ( y_outside [ int ( ymin_ind )], trap_1D_Y_outside [ int ( ymin_ind )], \"ro\" ) ( lx ,) = ax [ 1 ] . plot ( axis1 , trap_1D_X_allw , linewidth = 2 , color = \"royalblue\" ) ( lz ,) = ax [ 2 ] . plot ( axis2 , trap_1D_Z_allw , linewidth = 2 , color = \"royalblue\" ) ( point1 ,) = ax [ 1 ] . plot ( axis1 [ index_1 ], trap_1D_X_allw [ index_1 ], \"ro\" ) ( point2 ,) = ax [ 2 ] . plot ( axis2 [ index_2 ], trap_1D_Z_allw [ index_2 ], \"ro\" ) else : ( lx ,) = ax [ 1 ] . plot ( axis1 , np . zeros (( len ( axis1 ),)), linewidth = 2 , color = \"royalblue\" ) ( lz ,) = ax [ 2 ] . plot ( axis2 , np . zeros (( len ( axis2 ),)), linewidth = 2 , color = \"royalblue\" ) plt . grid ( alpha = 0.5 ) for k in range ( len ( ax )): ax [ k ] . set_xlabel ( \" %s (m)\" % ( axis_name_list [ k ] . lower ()), fontsize = 14 ) plt . setp ( ax [ k ] . spines . values (), linewidth = 2 ) ax [ k ] . axhline ( y = 0 , color = \"black\" , linestyle = \"--\" , linewidth = 2 ) ax [ k ] . tick_params ( axis = \"both\" , which = \"major\" , labelsize = 14 ) ax [ 0 ] . set_title ( \"Total dipole trap for mf = %s in the 3 directions\" % ( mf [ 0 ]), fontsize = 18 ) fig . text ( 0.21 , 0.5 , \"Potential (mK)\" , ha = \"center\" , va = \"center\" , rotation = \"vertical\" , fontsize = 14 ) def updateP ( val ): P = [] for ( k , slider ) in enumerate ( slider_ax ): P . append ( slider . val * mW ) self . simul . trap . set_powers ( P ) mf_index , edge , y_outside , trap_1D_Y = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) ymin_ind , y_min , trap_depth , trap_prominence , _ = self . get_min_trap ( y_outside , trap_1D_Y ) print ( \"y_min = \" , y_min ) ax [ 0 ] . set_ylim ([ - 2 , trap_1D_Y . max ()]) axcolor = \"lightgoldenrodyellow\" props = dict ( boxstyle = \"round\" , facecolor = axcolor , alpha = 0.5 ) if not np . isnan ( y_min ): min_pos = np . zeros ( 3 ) min_pos [ axis_index ] = y_min + edge min_pos [ axis1_index ] = coord1 min_pos [ axis2_index ] = coord2 _ , _ , y_outside , trap_1D_Y = self . get_coord_trap_outside_structure ( self . trapping_axis , coord1 , coord2 , mf , edge_no_surface = None ) omegay = self . get_trapfreq ( y_outside , trap_1D_Y ) _ , _ , x_outside , trap_1D_X = self . get_coord_trap_outside_structure ( axis1_name , np . delete ( min_pos , axis1_index )[ 0 ], np . delete ( min_pos , axis1_index )[ 1 ], mf , edge_no_surface = None , ) omegax = self . get_trapfreq ( x_outside , trap_1D_X ) _ , _ , z_outside , trap_1D_Z = self . get_coord_trap_outside_structure ( axis2_name , np . delete ( min_pos , axis2_index )[ 0 ], np . delete ( min_pos , axis2_index )[ 1 ], mf , edge_no_surface = None , ) omegaz = self . get_trapfreq ( z_outside , trap_1D_Z ) lx . set_ydata ( trap_1D_X ) lz . set_ydata ( trap_1D_Z ) point . set_data ( y_outside [ ymin_ind ], trap_1D_Y [ ymin_ind ]) point1 . set_data ( axis1 [ index_1 ], trap_1D_X [ index_1 ]) point2 . set_data ( axis2 [ index_2 ], trap_1D_Z [ index_2 ]) ax [ 1 ] . set_ylim ([ trap_1D_X . min (), trap_1D_X . max ()]) ax [ 2 ] . set_ylim ([ trap_1D_Z . min (), trap_1D_Z . max ()]) ax [ 0 ] . set_ylim ([ 2 * trap_depth , 2 * trap_1D_Y . max ()]) textstr = \" \\n \" . join ( ( r \"$\\mathrm{trap \\, position}= %.2f (nm) $\" % ( y_min * 1e9 ,), r \"$\\mathrm {depth} = %.2f (mK) $\" % ( trap_depth ,), r \"$\\omega_ %s = %.2f (kHz) $\" % ( self . trapping_axis , omegay * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis1_name , omegax * 1e-3 , ), r \"$\\omega_ %s = %.2f (kHz) $\" % ( axis2_name , omegaz * 1e-3 , ), ) ) box . set_text ( textstr ) else : textstr = r \"$\\mathrm {depth} = %.2f (mK) $\" % ( trap_depth ,) box . set_text ( textstr ) ly . set_ydata ( np . squeeze ( np . real ( trap_1D_Y ))) for slider in slider_ax : slider . on_changed ( updateP ) plt . show () return fig , ax , slider_ax","title":"plot_3axis()"},{"location":"reference/viz/#nanotrappy.utils.viz.Viz.plot_trap","text":"Shows a 2D plot of the total potential with power sliders Only available if a 2D simulation has been run. Parameters: Name Type Description Default plane str As we are dealing with 2D plots, we have to specify required mf int Mixed mf state we want to plot. In 2D we can only 0 Pranges list List with the maximum values of the beam powers [10, 10] Exceptions: Type Description TypeError if only a 1D computation of the potential has been Returns: Type Description (tuple) - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) Source code in nanotrappy\\utils\\viz.py def plot_trap ( self , mf = 0 , Pranges = [ 10 , 10 ], increments = [ 0.1 , 0.1 ]): \"\"\"Shows a 2D plot of the total potential with power sliders Only available if a 2D simulation has been run. Args: plane (str): As we are dealing with 2D plots, we have to specify the plane we are looking at to choose the right coordinates for plotting. mf (int): Mixed mf state we want to plot. In 2D we can only specify one integer. Default to 0. Pranges (list): List with the maximum values of the beam powers we want to display on the sliders. Defaults to [10,10] Raise: TypeError: if only a 1D computation of the potential has been done before plotting. Returns: (tuple): containing: - fig: figure - ax: axis of figure - slider_ax: sliders (needed for interactivity of the sliders) \"\"\" if np . ndim ( self . simul . total_potential ()) <= 2 : raise TypeError ( \"This method can only be used if a 2D computation of the potential has been done\" ) if len ( Pranges ) != len ( self . simul . trap . beams ): raise ValueError ( \"When specifying the upper ranges of P for plotting, you have to give as many as many values as there are beams.\" ) _ , mf = check_mf ( self . simul . atomicsystem . f , mf ) dimension = self . simul . geometry . get_dimension () # coord1, coord2 = set_axis_from_plane(plane, self.simul) if dimension == 2 : mf_index = int ( mf + self . simul . atomicsystem . f ) axis1 , axis2 = self . simul . geometry . get_base_axes () coord1 = axis1 . fetch_in ( self . simul ) coord2 = axis2 . fetch_in ( self . simul ) # coord1, coord2 = getattr(self.simul, axis1.name), getattr(self.simul, axis2.name) trap = np . real ( self . simul . total_potential ())[:, :, mf_index ] trap_noCP = np . real ( self . simul . total_potential_noCP [:, :, mf_index ]) fig , ax = plt . subplots () plt . subplots_adjust ( left = 0.5 , bottom = 0.1 ) # the norm TwoSlopeNorm allows to fix the 0 of potential to the white color, so that we can easily distinguish between positive and negative values of the potential a = ax . pcolormesh ( coord1 / nm , coord2 / nm , np . transpose ( trap ), shading = \"gouraud\" , norm = colors . TwoSlopeNorm ( vmin = min ( np . min ( trap_noCP ), - 0.001 ), vcenter = 0 , vmax = max ( np . max ( trap_noCP ) * 2 , 0.001 ) ), cmap = \"seismic_r\" , ) cbar = plt . colorbar ( a ) cbar . set_label ( \"Total potential (mK)\" , rotation = 270 , labelpad = 12 , fontsize = 14 ) ax . set_xlabel ( \" %s (nm)\" % ( self . simul . geometry . name [ 0 ] . lower ()), fontsize = 14 ) ax . set_ylabel ( \" %s (nm)\" % ( self . simul . geometry . name [ 1 ] . lower ()), fontsize = 14 ) plt . setp ( ax . spines . values (), linewidth = 1.5 ) ax . tick_params ( axis = \"both\" , which = \"major\" , labelsize = 14 ) ax . set_title ( \"2D plot of trapping potential \\n for mf = %s in the %s plane\" % ( mf , self . simul . geometry . name ), fontsize = 18 , ) ax . margins ( x = 0 ) axcolor = \"lightgoldenrodyellow\" slider_ax = [] axes = [] for ( k , beam ) in enumerate ( self . simul . trap . beams ): axes . append ( plt . axes ([ 0.15 + k * 0.08 , 0.1 , 0.03 , 0.75 ], facecolor = axcolor )) slider_ax . append ( Slider ( axes [ k ], \"Power \\n Beam %s (mW)\" % ( k + 1 ), 0 , Pranges [ k ], valinit = self . simul . trap . beams [ k ] . get_power () * 1e3 , valstep = increments [ k ], orientation = \"vertical\" , ) ) elif dimension == 1 : mf_index = mf + [ self . simul . atomicsystem . f ] # x = getattr(self.simul, self.simul.geometry.name) x = self . simul . geometry . fetch_in ( self . simul ) fig , ax = plt . subplots () plt . subplots_adjust ( bottom = 0.27 ) jet = cm = plt . get_cmap ( \"Greys\" ) cNorm = colors . Normalize ( vmin =- 1 , vmax = len ( mf )) scalarMap = cmx . ScalarMappable ( norm = cNorm , cmap = jet ) a = [] trap = np . real ( self . simul . total_potential ()[ 0 ]) trap_noCP = np . real ( self . simul . total_potential_noCP ) ax . set_xlabel ( \" %s (nm)\" % ( self . simul . geometry . name ), fontsize = 14 ) ax . set_ylabel ( \"E (mK)\" , fontsize = 14 ) plt . setp ( ax . spines . values (), linewidth = 1.5 ) ax . axhline ( y = 0 , color = \"black\" , linestyle = \"--\" , linewidth = 2 ) ax . tick_params ( axis = \"both\" , which = \"major\" , labelsize = 14 ) ax . set_title ( \"1D plot of trapping potential \\n for mf = %s along %s \" % ( mf , self . simul . geometry . name ), fontsize = 18 ) for k in range ( len ( mf_index )): colorVal = \"k\" # scalarMap.to_rgba(k) a = a + plt . plot ( x / nm , trap [:, mf_index [ k ]], color = colorVal , label = \"m$_f$ = %s \" % ( mf [ k ]), linewidth = 2 + 3 / len ( self . simul . mf_all ), ) if len ( mf ) == 1 and len ( self . simul . trap . beams ) == 2 : ( b ,) = plt . plot ( x / nm , np . real ( self . simul . trap . beams [ 0 ] . get_power () * np . real ( self . simul . potentials [ 0 , :, mf_index [ 0 ]])), color = \"blue\" , linewidth = 2 , ) ( r ,) = plt . plot ( x / nm , np . real ( self . simul . trap . beams [ 1 ] . get_power () * np . real ( self . simul . potentials [ 1 , :, mf_index [ 0 ]])), color = \"red\" , linewidth = 2 , ) else : pass # plt.legend() axcolor = \"lightgoldenrodyellow\" slider_ax = [] axes = [] for ( k , beam ) in enumerate ( self . simul . trap . beams ): axes . append ( plt . axes ([ 0.25 , 0.15 - k * 0.1 , 0.6 , 0.03 ], facecolor = axcolor )) slider_ax . append ( Slider ( axes [ k ], \"Power \\n Beam %s (mW)\" % ( k + 1 ), 0 , Pranges [ k ], valinit = self . simul . trap . beams [ k ] . get_power () * 1e3 , valstep = increments [ k ], ) ) slider_ax [ k ] . label . set_size ( 14 ) cursor = mplcursors . cursor ( a , highlight = True , highlight_kwargs = _custom_highlight_kwargs , annotation_kwargs = _custom_annotation_kwargs , ) @cursor . connect ( \"add\" ) def on_add ( sel ): artist = sel . artist label = artist . get_label () or \"\" mf = self . simul . atomicsystem . f + int ( label . split ()[ 2 ]) label = f \"Choice : { label } \" idx = int ( sel . target . index ) temp_vec = self . simul . total_vecs [ idx , mf ] temp_vec = np . abs ( temp_vec ) ** 2 decomp = f \"State : { vec_to_string ( temp_vec ) } \" x , y = sel . target textx = f \"x = { x : .1f } nm\" texty = f \"y = { y : .2f } mK\" size = max ( len ( textx ), len ( texty ), len ( decomp )) label = label . center ( size , \"-\" ) text = f \" { label } \\n { textx } \\n { texty } \\n { decomp } \" sel . annotation . set_text ( text ) def updateP ( val ): if dimension == 1 : for selection in cursor . selections : cursor . remove_selection ( selection ) P = [] for ( k , slider ) in enumerate ( slider_ax ): P . append ( slider . val * mW ) self . simul . trap . set_powers ( P ) trap = np . real ( self . simul . total_potential ()[ 0 ]) ### weird [0] for k in range ( len ( mf )): trap_k = trap [:, mf_index [ k ]] a [ k ] . set_ydata ( trap_k ) if len ( mf ) == 1 and len ( self . simul . trap . beams ) == 2 : b . set_ydata ( np . real ( self . simul . trap . beams [ 0 ] . get_power () * np . real ( self . simul . potentials [ 0 , :, mf_index [ 0 ]]) ) ) r . set_ydata ( np . real ( self . simul . trap . beams [ 1 ] . get_power () * np . real ( self . simul . potentials [ 1 , :, mf_index [ 0 ]]) ) ) elif dimension == 2 : P = [] for ( k , slider ) in enumerate ( slider_ax ): P . append ( slider . val * mW ) self . simul . trap . set_powers ( P ) trap_2D = self . simul . total_potential ()[:, :, mf_index ] a . set_array ( np . transpose ( np . real ( self . simul . total_potential_noCP [:, :, mf_index ])) . ravel ()) a . autoscale () a . set_array ( np . transpose ( np . real ( trap_2D )) . ravel ()) fig . canvas . draw_idle () for slider in slider_ax : slider . on_changed ( updateP ) # s1, s2 = np.transpose(trap).shape # LnTr = LineSlice(a, s1, s2, coord1 / nm, coord2 / nm, ax2) plt . show () return fig , ax , slider_ax","title":"plot_trap()"}]}